diff --git a/doc/CMakeLists.txt b/doc/CMakeLists.txt
index 6561454a3d..e2a610dc1e 100644
--- a/doc/CMakeLists.txt
+++ b/doc/CMakeLists.txt
@@ -89,6 +89,7 @@ if(WITH_APIDOC)
       ${CMAKE_SOURCE_DIR}/src/core/providers/memory
       ${CMAKE_SOURCE_DIR}/src/core/raster
       ${CMAKE_SOURCE_DIR}/src/core/scalebar
+      ${CMAKE_SOURCE_DIR}/src/core/sensor
       ${CMAKE_SOURCE_DIR}/src/core/settings
       ${CMAKE_SOURCE_DIR}/src/core/symbology
       ${CMAKE_SOURCE_DIR}/src/core/textrenderer
diff --git a/python/core/auto_additions/qgis.py b/python/core/auto_additions/qgis.py
index b2e3cc67f3..41f132bde1 100644
--- a/python/core/auto_additions/qgis.py
+++ b/python/core/auto_additions/qgis.py
@@ -1154,13 +1154,20 @@ Qgis.GpsConnectionType.Gpsd.__doc__ = "GPSD device"
 Qgis.GpsConnectionType.__doc__ = 'GPS connection types.\n\n.. versionadded:: 3.30\n\n' + '* ``Automatic``: ' + Qgis.GpsConnectionType.Automatic.__doc__ + '\n' + '* ``Internal``: ' + Qgis.GpsConnectionType.Internal.__doc__ + '\n' + '* ``Serial``: ' + Qgis.GpsConnectionType.Serial.__doc__ + '\n' + '* ``Gpsd``: ' + Qgis.GpsConnectionType.Gpsd.__doc__
 # --
 Qgis.GpsConnectionType.baseClass = Qgis
-# monkey patching scoped based enum
-Qgis.GpsConnectionStatus.Disconnected.__doc__ = "Device is disconnected"
-Qgis.GpsConnectionStatus.Connecting.__doc__ = "Device is connecting"
-Qgis.GpsConnectionStatus.Connected.__doc__ = "Device is successfully connected"
-Qgis.GpsConnectionStatus.__doc__ = 'GPS connection status.\n\n.. versionadded:: 3.30\n\n' + '* ``Disconnected``: ' + Qgis.GpsConnectionStatus.Disconnected.__doc__ + '\n' + '* ``Connecting``: ' + Qgis.GpsConnectionStatus.Connecting.__doc__ + '\n' + '* ``Connected``: ' + Qgis.GpsConnectionStatus.Connected.__doc__
-# --
-Qgis.GpsConnectionStatus.baseClass = Qgis
+Qgis.GpsConnectionStatus = Qgis.DeviceConnectionStatus
+# monkey patching scoped based enum
+Qgis.Disconnected = Qgis.DeviceConnectionStatus.Disconnected
+Qgis.Disconnected.is_monkey_patched = True
+Qgis.Disconnected.__doc__ = "Device is disconnected"
+Qgis.Connecting = Qgis.DeviceConnectionStatus.Connecting
+Qgis.Connecting.is_monkey_patched = True
+Qgis.Connecting.__doc__ = "Device is connecting"
+Qgis.Connected = Qgis.DeviceConnectionStatus.Connected
+Qgis.Connected.is_monkey_patched = True
+Qgis.Connected.__doc__ = "Device is successfully connected"
+Qgis.DeviceConnectionStatus.__doc__ = 'GPS connection status.\n\n.. versionadded:: 3.30\n\n' + '* ``Disconnected``: ' + Qgis.DeviceConnectionStatus.Disconnected.__doc__ + '\n' + '* ``Connecting``: ' + Qgis.DeviceConnectionStatus.Connecting.__doc__ + '\n' + '* ``Connected``: ' + Qgis.DeviceConnectionStatus.Connected.__doc__
+# --
+Qgis.DeviceConnectionStatus.baseClass = Qgis
 QgsGpsInformation.FixStatus = Qgis.GpsFixStatus
 # monkey patching scoped based enum
 QgsGpsInformation.NoData = Qgis.GpsFixStatus.NoData
diff --git a/python/core/auto_generated/project/qgsproject.sip.in b/python/core/auto_generated/project/qgsproject.sip.in
index 9dd721e154..a1bb3c640d 100644
--- a/python/core/auto_generated/project/qgsproject.sip.in
+++ b/python/core/auto_generated/project/qgsproject.sip.in
@@ -782,6 +782,15 @@ the project.
 %End
 
 
+    QgsSensorManager *sensorManager();
+%Docstring
+Returns the project's sensor manager, which manages sensors within
+the project.
+
+.. versionadded:: 3.32
+%End
+
+
     QgsProjectViewSettings *viewSettings();
 %Docstring
 Returns the project's view settings, which contains settings and properties
diff --git a/python/core/auto_generated/qgis.sip.in b/python/core/auto_generated/qgis.sip.in
index 9b121dcec7..90d3e217d4 100644
--- a/python/core/auto_generated/qgis.sip.in
+++ b/python/core/auto_generated/qgis.sip.in
@@ -680,8 +680,8 @@ The development version
       Gpsd,
     };
 
-    enum class GpsConnectionStatus
-    {
+    enum class DeviceConnectionStatus
+      {
       Disconnected,
       Connecting,
       Connected,
diff --git a/python/core/auto_generated/qgsapplication.sip.in b/python/core/auto_generated/qgsapplication.sip.in
index 18af5ce928..ee42179d37 100644
--- a/python/core/auto_generated/qgsapplication.sip.in
+++ b/python/core/auto_generated/qgsapplication.sip.in
@@ -895,6 +895,13 @@ Using this shared model instead of creating a new :py:class:`QgsStyleModel` impr
 Returns the application font manager, which manages available fonts and font installation for the QGIS instance.
 
 .. versionadded:: 3.28
+%End
+
+    static QgsSensorRegistry *sensorRegistry() /KeepReference/;
+%Docstring
+Returns the application's sensor registry, used for sensor types.
+
+.. versionadded:: 3.32
 %End
 
     static QgsMessageLog *messageLog();
diff --git a/python/core/auto_generated/sensor/qgsabstractsensor.sip.in b/python/core/auto_generated/sensor/qgsabstractsensor.sip.in
new file mode 100644
index 0000000000..5ed514f8d3
--- /dev/null
+++ b/python/core/auto_generated/sensor/qgsabstractsensor.sip.in
@@ -0,0 +1,208 @@
+/************************************************************************
+ * This file has been generated automatically from                      *
+ *                                                                      *
+ * src/core/sensor/qgsabstractsensor.h                                  *
+ *                                                                      *
+ * Do not edit manually ! Edit header and run scripts/sipify.pl again   *
+ ************************************************************************/
+
+
+
+class QgsAbstractSensor : QObject
+{
+%Docstring(signature="appended")
+An abstract base class for sensor classes
+
+.. versionadded:: 3.32
+%End
+
+%TypeHeaderCode
+#include "qgsabstractsensor.h"
+#include "qgsiodevicesensor.h"
+#include "qgssensorregistry.h"
+%End
+%ConvertToSubClassCode
+    if ( QgsAbstractSensor *item = qobject_cast< QgsAbstractSensor * >( sipCpp ) )
+    {
+      if ( item->type() == QLatin1String( "tcp_socket" ) && dynamic_cast<QgsTcpSocketSensor *>( item ) != NULL )
+      {
+        sipType = sipType_QgsTcpSocketSensor;
+      }
+      else if ( item->type() == QLatin1String( "udp_socket" ) && dynamic_cast<QgsUdpSocketSensor *>( item ) != NULL )
+      {
+        sipType = sipType_QgsUdpSocketSensor;
+      }
+      else if ( item->type() == QLatin1String( "serial_port" ) && dynamic_cast<QgsSerialPortSensor *>( item ) != NULL )
+      {
+        sipType = sipType_QgsSerialPortSensor;
+      }
+      else
+      {
+        sipType = sipType_QgsAbstractSensor;
+      }
+    }
+    else
+    {
+      sipType = NULL;
+    }
+%End
+  public:
+
+    struct SensorData
+    {
+
+      QVariant lastValue;
+
+      QDateTime lastTimestamp;
+    };
+
+    explicit QgsAbstractSensor( QObject *parent /TransferThis/ = 0 );
+%Docstring
+Constructor for an abstract sensor, bound to the specified ``parent``.
+%End
+    virtual ~QgsAbstractSensor();
+
+    QString id() const;
+%Docstring
+Returns the sensor ID.
+
+.. note::
+
+   This is a autogenerated unique string identifying an individual sensor.
+%End
+
+    virtual QString type() const;
+%Docstring
+Returns the sensor type. This will match the type string of the sensor class, as used by :py:class:`QgsSensorRegistry`.
+%End
+
+    QString name() const;
+%Docstring
+Returns the user-friendly name identifying the sensor.
+%End
+
+    void setName( const QString &name );
+%Docstring
+Sets the  user-friendly name identfying the sensor.
+%End
+
+    Qgis::DeviceConnectionStatus status() const;
+%Docstring
+Returns the current sensor status.
+%End
+
+    void setStatus( Qgis::DeviceConnectionStatus status );
+%Docstring
+Sets the current sensor ``status``.
+%End
+
+    void connectSensor();
+%Docstring
+Connects the sensor to its source.
+%End
+
+    void disconnectSensor();
+%Docstring
+Disconnects the sensor from its source.
+%End
+
+    QgsAbstractSensor::SensorData data() const;
+%Docstring
+Returns the latest captured data from the sensor.
+%End
+
+    void setData( const QgsAbstractSensor::SensorData &data );
+%Docstring
+Sets the latest captured data from the sensor.
+%End
+
+    QString errorString() const;
+%Docstring
+Returns the last error message.
+%End
+
+    bool writeXml( QDomElement &parentElement, QDomDocument &document ) const;
+%Docstring
+Write generic sensor properties into a DOM element.
+
+:param parentElement: parent DOM element (e.g 'Sensors' element)
+:param document: DOM document
+%End
+
+    bool readXml( const QDomElement &element, const QDomDocument &document );
+%Docstring
+Restores generic sensor details from a DOM element.
+
+:param element: DOM node corresponding to item (e.g. 'Sensor' element)
+:param document: DOM document
+%End
+
+    virtual bool writePropertiesToElement( QDomElement &element, QDomDocument &document ) const;
+%Docstring
+Write specific sensor type properties into a DOM element.
+
+:param element: DOM node corresponding to item (e.g. 'Sensor' element)
+:param document: DOM document
+%End
+
+    virtual bool readPropertiesFromElement( const QDomElement &element, const QDomDocument &document );
+%Docstring
+Restores specific sensor type properties from a DOM element.
+
+:param element: DOM node corresponding to item (e.g. 'Sensor' element)
+:param document: DOM document
+%End
+
+  signals:
+
+    void nameChanged();
+%Docstring
+Emitted when the sensor name has changed.
+%End
+
+    void statusChanged();
+%Docstring
+Emitted when the sensor status has changed.
+%End
+
+    void dataChanged();
+%Docstring
+Emitted when the captured sensor data has changed.
+%End
+
+    void errorOccurred( const QString &errorString );
+%Docstring
+Emitted when an error has occurred. The ``errorString`` describes the error.
+%End
+
+  protected:
+
+    virtual void handleConnect() = 0;
+%Docstring
+Handles the connection to the sensor.
+
+.. note::
+
+   Triggered by calling :py:func:`~QgsAbstractSensor.connectSensor`
+%End
+
+    virtual void handleDisconnect() = 0;
+%Docstring
+Handles the disconnection from the sensor.
+
+.. note::
+
+   Triggered by calling :py:func:`~QgsAbstractSensor.disconnectSensor`
+%End
+
+
+};
+
+
+/************************************************************************
+ * This file has been generated automatically from                      *
+ *                                                                      *
+ * src/core/sensor/qgsabstractsensor.h                                  *
+ *                                                                      *
+ * Do not edit manually ! Edit header and run scripts/sipify.pl again   *
+ ************************************************************************/
diff --git a/python/core/auto_generated/sensor/qgsiodevicesensor.sip.in b/python/core/auto_generated/sensor/qgsiodevicesensor.sip.in
new file mode 100644
index 0000000000..b3c892fca4
--- /dev/null
+++ b/python/core/auto_generated/sensor/qgsiodevicesensor.sip.in
@@ -0,0 +1,252 @@
+/************************************************************************
+ * This file has been generated automatically from                      *
+ *                                                                      *
+ * src/core/sensor/qgsiodevicesensor.h                                  *
+ *                                                                      *
+ * Do not edit manually ! Edit header and run scripts/sipify.pl again   *
+ ************************************************************************/
+
+
+
+
+
+class QgsIODeviceSensor : QgsAbstractSensor
+{
+%Docstring(signature="appended")
+An abstract class QIODevice-based sensor classes
+
+.. versionadded:: 3.32
+%End
+
+%TypeHeaderCode
+#include "qgsiodevicesensor.h"
+%End
+  public:
+
+    explicit QgsIODeviceSensor( QObject *parent = 0 );
+%Docstring
+Constructor for a abstract QIODevice-based sensor, bound to the specified ``parent``.
+%End
+    ~QgsIODeviceSensor();
+
+    QIODevice *iODevice() const;
+%Docstring
+Returns the I/O device.
+%End
+
+  protected:
+
+    void initIODevice( QIODevice *device /Transfer/ );
+%Docstring
+Initiates the I/O ``device``.
+
+.. note::
+
+   Takes ownership of the device.
+%End
+
+  protected slots:
+
+    virtual void parseData();
+%Docstring
+Parses the data read from the device when available.
+%End
+
+};
+
+class QgsTcpSocketSensor : QgsIODeviceSensor
+{
+%Docstring(signature="appended")
+A TCP socket sensor class
+
+.. versionadded:: 3.32
+%End
+
+%TypeHeaderCode
+#include "qgsiodevicesensor.h"
+%End
+  public:
+
+    explicit QgsTcpSocketSensor( QObject *parent = 0 );
+%Docstring
+Constructor for a TCP socket sensor, bound to the specified ``parent``.
+%End
+    ~QgsTcpSocketSensor();
+
+    static QgsTcpSocketSensor *create( QObject *parent ) /Factory/;
+%Docstring
+Returns a new TCP socket sensor.
+
+The caller takes responsibility for deleting the returned object.
+%End
+
+    virtual QString type() const;
+
+
+    QString hostName() const;
+%Docstring
+Returns the host name the socket connects to.
+%End
+
+    void setHostName( const QString &hostName );
+%Docstring
+Sets the host name the socket connects to.
+
+:param hostName: the host name string (a domain name or an IP address)
+%End
+
+    int port() const;
+%Docstring
+Returns the port the socket connects to.
+%End
+
+    void setPort( int port );
+%Docstring
+Sets the ``port`` the socket connects to.
+%End
+
+    virtual bool writePropertiesToElement( QDomElement &element, QDomDocument &document ) const;
+
+    virtual bool readPropertiesFromElement( const QDomElement &element, const QDomDocument &document );
+
+
+  protected:
+
+    virtual void handleConnect();
+
+    virtual void handleDisconnect();
+
+
+};
+
+class QgsUdpSocketSensor : QgsIODeviceSensor
+{
+%Docstring(signature="appended")
+A UDP socket sensor class
+
+.. versionadded:: 3.32
+%End
+
+%TypeHeaderCode
+#include "qgsiodevicesensor.h"
+%End
+  public:
+
+    explicit QgsUdpSocketSensor( QObject *parent = 0 );
+%Docstring
+Constructor for a UDP socket sensor, bound to the specified ``parent``.
+%End
+    ~QgsUdpSocketSensor();
+
+    static QgsUdpSocketSensor *create( QObject *parent ) /Factory/;
+%Docstring
+Returns a new UDP socket sensor.
+
+The caller takes responsibility for deleting the returned object.
+%End
+
+    virtual QString type() const;
+
+
+    QString hostName() const;
+%Docstring
+Returns the host name the socket connects to.
+%End
+
+    void setHostName( const QString &hostName );
+%Docstring
+Sets the host name the socket connects to.
+
+:param hostName: the host name string (a domain name or an IP address)
+%End
+
+    int port() const;
+%Docstring
+Returns the port the socket connects to.
+%End
+
+    void setPort( int port );
+%Docstring
+Sets the ``port`` the socket connects to.
+%End
+
+    virtual bool writePropertiesToElement( QDomElement &element, QDomDocument &document ) const;
+
+    virtual bool readPropertiesFromElement( const QDomElement &element, const QDomDocument &document );
+
+
+  protected:
+
+    virtual void handleConnect();
+
+    virtual void handleDisconnect();
+
+
+};
+
+
+class QgsSerialPortSensor : QgsIODeviceSensor
+{
+%Docstring(signature="appended")
+A serial port sensor class
+
+.. versionadded:: 3.32
+%End
+
+%TypeHeaderCode
+#include "qgsiodevicesensor.h"
+%End
+  public:
+
+    explicit QgsSerialPortSensor( QObject *parent = 0 );
+%Docstring
+Constructor for a serial port sensor, bound to the specified ``parent``.
+%End
+    ~QgsSerialPortSensor();
+
+    static QgsSerialPortSensor *create( QObject *parent ) /Factory/;
+%Docstring
+Returns a new serial port sensor.
+
+The caller takes responsibility for deleting the returned object.
+%End
+
+    virtual QString type() const;
+
+
+    QString portName() const;
+%Docstring
+Returns the serial port the sensor connects to.
+%End
+
+    void setPortName( const QString &portName );
+%Docstring
+Sets the serial port the sensor connects to.
+
+:param portName: the port name (e.g. COM4)
+%End
+
+    virtual bool writePropertiesToElement( QDomElement &element, QDomDocument &document ) const;
+
+    virtual bool readPropertiesFromElement( const QDomElement &element, const QDomDocument &document );
+
+
+  protected:
+
+    virtual void handleConnect();
+
+    virtual void handleDisconnect();
+
+
+};
+
+
+
+
+/************************************************************************
+ * This file has been generated automatically from                      *
+ *                                                                      *
+ * src/core/sensor/qgsiodevicesensor.h                                  *
+ *                                                                      *
+ * Do not edit manually ! Edit header and run scripts/sipify.pl again   *
+ ************************************************************************/
diff --git a/python/core/auto_generated/sensor/qgssensormanager.sip.in b/python/core/auto_generated/sensor/qgssensormanager.sip.in
new file mode 100644
index 0000000000..9773496e1a
--- /dev/null
+++ b/python/core/auto_generated/sensor/qgssensormanager.sip.in
@@ -0,0 +1,149 @@
+/************************************************************************
+ * This file has been generated automatically from                      *
+ *                                                                      *
+ * src/core/sensor/qgssensormanager.h                                   *
+ *                                                                      *
+ * Do not edit manually ! Edit header and run scripts/sipify.pl again   *
+ ************************************************************************/
+
+
+
+
+
+class QgsSensorManager : QObject
+{
+%Docstring(signature="appended")
+
+Manages sensors.
+
+:py:class:`QgsSensorManager` handles the storage, serializing and deserializing
+of sensors. Usually this class is not constructed directly, but
+rather accessed through a :py:class:`QgsProject` via :py:func:`QgsProject.sensorManager()`.
+
+.. versionadded:: 3.32
+%End
+
+%TypeHeaderCode
+#include "qgssensormanager.h"
+%End
+  public:
+
+    explicit QgsSensorManager( QObject *parent /TransferThis/ = 0 );
+%Docstring
+Constructor for QgsSensorManager, with the specified ``parent`` object.
+%End
+
+    ~QgsSensorManager();
+
+    void clear();
+%Docstring
+Deregisters and removes all sensors from the manager.
+%End
+
+    QList<QgsAbstractSensor *> sensors() const;
+%Docstring
+Returns a list of pointers to all registered sensors.
+%End
+
+    QgsAbstractSensor *sensor( const QString &id ) const;
+%Docstring
+Returns a registered sensor pointer matching a given ``id``. If not
+matching sensor is found, a ``None`` will be returned.
+%End
+
+    void addSensor( QgsAbstractSensor *sensor /Transfer/ );
+%Docstring
+Registers a new ``sensor``.
+The sensor name does not require uniqueness; sensors will the same
+name will store their data in the same sensor name key, allowing for
+registration of sensors to cover multiple devices (e.g. two serial port
+sensors with alternative port name to cover two machines).
+
+.. note::
+
+   Takes ownership of the sensor.
+%End
+
+    bool removeSensor( const QString &id );
+%Docstring
+Removes a registered sensor matching a given ``id``.
+
+:return: ``True`` if a sensor was removed.
+%End
+
+    QStringList sensorNames() const;
+%Docstring
+Returns a list of registered sensor names.
+%End
+
+    QgsAbstractSensor::SensorData sensorData( const QString &name ) const;
+%Docstring
+Returns the last captured data from a registered sensor matching a given ``name``.
+%End
+
+    QMap<QString, QgsAbstractSensor::SensorData> sensorsData() const;
+%Docstring
+Returns the last captured data of all registered sensors.
+%End
+
+    bool readXml( const QDomElement &element, const QDomDocument &document );
+%Docstring
+Reads the manager's state from a DOM element, restoring all sensors
+present in the XML document.
+
+.. seealso:: :py:func:`writeXml`
+%End
+
+    QDomElement writeXml( QDomDocument &document ) const;
+%Docstring
+Returns a DOM element representing the state of the manager.
+
+.. seealso:: :py:func:`readXml`
+%End
+
+  signals:
+
+    void sensorAdded( const QString &id );
+%Docstring
+Emitted when a sensor has been registered.
+%End
+
+    void sensorAboutToBeRemoved( const QString &id );
+%Docstring
+Emitted when a sensor is about to be removed.
+%End
+
+    void sensorRemoved( const QString &id );
+%Docstring
+Emitted when a sensor has been removed.
+%End
+
+    void sensorNameChanged( const QString &id );
+%Docstring
+Emitted when a sensor name has changed.
+%End
+
+    void sensorStatusChanged( const QString &id );
+%Docstring
+Emitted when a sensor status has changed.
+%End
+
+    void sensorDataCaptured( const QString &id );
+%Docstring
+Emitted when newly captured data from a sensor has occurred.
+%End
+
+    void sensorErrorOccurred( const QString &id );
+%Docstring
+Emitted when a sensor error has occurred.
+%End
+
+};
+
+/************************************************************************
+ * This file has been generated automatically from                      *
+ *                                                                      *
+ * src/core/sensor/qgssensormanager.h                                   *
+ *                                                                      *
+ * Do not edit manually ! Edit header and run scripts/sipify.pl again   *
+ ************************************************************************/
diff --git a/python/core/auto_generated/sensor/qgssensormodel.sip.in b/python/core/auto_generated/sensor/qgssensormodel.sip.in
new file mode 100644
index 0000000000..810a868c9b
--- /dev/null
+++ b/python/core/auto_generated/sensor/qgssensormodel.sip.in
@@ -0,0 +1,73 @@
+/************************************************************************
+ * This file has been generated automatically from                      *
+ *                                                                      *
+ * src/core/sensor/qgssensormodel.h                                     *
+ *                                                                      *
+ * Do not edit manually ! Edit header and run scripts/sipify.pl again   *
+ ************************************************************************/
+
+
+
+
+
+class QgsSensorModel: QAbstractItemModel
+{
+%Docstring(signature="appended")
+A QAbstractItemModel subclass for showing sensors within a :py:class:`QgsSensorManager`.
+
+.. versionadded:: 3.32
+%End
+
+%TypeHeaderCode
+#include "qgssensormodel.h"
+%End
+  public:
+
+    enum class Column
+    {
+      Name,
+      LastValue,
+    };
+
+    enum Role
+    {
+      SensorType,
+      SensorId,
+      SensorName,
+      SensorStatus,
+      SensorLastValue,
+      SensorLastTimestamp,
+      Sensor,
+    };
+
+    explicit QgsSensorModel( QgsSensorManager *manager, QObject *parent /TransferThis/ = 0 );
+%Docstring
+Constructor for QgsSensorModel, for the specified ``manager`` and ``parent`` object.
+%End
+
+    virtual QVariant data( const QModelIndex &index, int role ) const;
+
+    virtual bool setData( const QModelIndex &index, const QVariant &value, int role = Qt::EditRole );
+
+    virtual Qt::ItemFlags flags( const QModelIndex &index ) const;
+
+     virtual QVariant headerData( int section, Qt::Orientation orientation,
+                         int role = Qt::DisplayRole ) const;
+     virtual QModelIndex index( int row, int column,
+                       const QModelIndex &parent = QModelIndex() ) const;
+    virtual QModelIndex parent( const QModelIndex &index ) const;
+
+    virtual int rowCount( const QModelIndex &parent = QModelIndex() ) const;
+
+    virtual int columnCount( const QModelIndex &parent = QModelIndex() ) const;
+
+
+};
+
+/************************************************************************
+ * This file has been generated automatically from                      *
+ *                                                                      *
+ * src/core/sensor/qgssensormodel.h                                     *
+ *                                                                      *
+ * Do not edit manually ! Edit header and run scripts/sipify.pl again   *
+ ************************************************************************/
diff --git a/python/core/auto_generated/sensor/qgssensorregistry.sip.in b/python/core/auto_generated/sensor/qgssensorregistry.sip.in
new file mode 100644
index 0000000000..fe1ecebb38
--- /dev/null
+++ b/python/core/auto_generated/sensor/qgssensorregistry.sip.in
@@ -0,0 +1,143 @@
+/************************************************************************
+ * This file has been generated automatically from                      *
+ *                                                                      *
+ * src/core/sensor/qgssensorregistry.h                                  *
+ *                                                                      *
+ * Do not edit manually ! Edit header and run scripts/sipify.pl again   *
+ ************************************************************************/
+
+
+class QgsSensorAbstractMetadata
+{
+%Docstring(signature="appended")
+Stores metadata about a sensor class.
+
+.. note::
+
+   In C++ you can use :py:class:`QgsSensorAbstractMetadata` convenience class.
+
+.. versionadded:: 3.32
+%End
+
+%TypeHeaderCode
+#include "qgssensorregistry.h"
+%End
+  public:
+
+    QgsSensorAbstractMetadata( const QString &type, const QString &visibleName );
+%Docstring
+Constructor for QgsSensorAbstractMetadata with the specified class ``type``.
+%End
+
+    virtual ~QgsSensorAbstractMetadata();
+
+    QString type() const;
+%Docstring
+Returns the unique type code for the sensor class.
+%End
+
+    QString visibleName() const;
+%Docstring
+Returns a translated, user visible name for the sensor class.
+%End
+
+
+    virtual QgsAbstractSensor *createSensor( QObject *parent ) = 0 /TransferBack/;
+%Docstring
+Creates a sensor of this class.
+%End
+
+};
+
+
+
+class QgsSensorRegistry : QObject
+{
+%Docstring(signature="appended")
+Registry of available sensor types.
+
+:py:class:`QgsSensorRegistry` is not usually directly created, but rather accessed through
+:py:func:`QgsApplication.sensorRegistry()`.
+
+A companion class, :py:class:`QgsSensorGuiRegistry`, handles the GUI behavior
+of sensors.
+
+.. versionadded:: 3.32
+%End
+
+%TypeHeaderCode
+#include "qgssensorregistry.h"
+%End
+  public:
+
+    QgsSensorRegistry( QObject *parent = 0 );
+%Docstring
+Creates a new empty item registry.
+
+QgsSensorRegistry is not usually directly created, but rather accessed through
+:py:func:`QgsApplication.sensorRegistry()`.
+
+.. seealso:: :py:func:`populate`
+%End
+    ~QgsSensorRegistry();
+
+    bool populate();
+%Docstring
+Populates the registry with standard sensor types. If called on a non-empty registry
+then this will have no effect and will return ``False``.
+%End
+
+
+    QgsSensorAbstractMetadata *sensorMetadata( const QString &type ) const;
+%Docstring
+Returns the metadata for the specified sensor ``type``. Returns ``None`` if
+a corresponding type was not found in the registry.
+%End
+
+
+    bool addSensorType( QgsSensorAbstractMetadata *metadata /Transfer/ );
+%Docstring
+Registers a new sensor type.
+
+.. note::
+
+   Takes ownership of the metadata instance.
+%End
+
+    bool removeSensorType( const QString &type );
+%Docstring
+Removes a new a sensor type from the registry.
+%End
+
+    QgsAbstractSensor *createSensor( const QString &type, QObject *parent = 0 ) const /TransferBack/;
+%Docstring
+Creates a new instance of a sensor given the ``type``.
+%End
+
+    QMap<QString, QString> sensorTypes() const;
+%Docstring
+Returns a map of available sensor types to translated name.
+%End
+
+  signals:
+
+    void sensorAdded( const QString &type, const QString &name );
+%Docstring
+Emitted whenever a new sensor type is added to the registry, with the specified
+``type`` and visible ``name``.
+%End
+
+  private:
+    QgsSensorRegistry( const QgsSensorRegistry &rh );
+};
+
+
+
+
+/************************************************************************
+ * This file has been generated automatically from                      *
+ *                                                                      *
+ * src/core/sensor/qgssensorregistry.h                                  *
+ *                                                                      *
+ * Do not edit manually ! Edit header and run scripts/sipify.pl again   *
+ ************************************************************************/
diff --git a/python/core/core_auto.sip b/python/core/core_auto.sip
index 30661d87ad..9cd73b28b4 100644
--- a/python/core/core_auto.sip
+++ b/python/core/core_auto.sip
@@ -702,6 +702,11 @@
 %Include auto_generated/textrenderer/qgstextrenderer.sip
 %Include auto_generated/textrenderer/qgstextrendererutils.sip
 %Include auto_generated/textrenderer/qgstextshadowsettings.sip
+%Include auto_generated/sensor/qgssensormodel.sip
+%Include auto_generated/sensor/qgssensormanager.sip
+%Include auto_generated/sensor/qgssensorregistry.sip
+%Include auto_generated/sensor/qgsabstractsensor.sip
+%Include auto_generated/sensor/qgsiodevicesensor.sip
 %Include auto_generated/settings/qgssettings.sip
 %Include auto_generated/settings/qgssettingsentry.sip
 %Include auto_generated/settings/qgssettingsentrygroup.sip
diff --git a/resources/function_help/json/sensor_data b/resources/function_help/json/sensor_data
new file mode 100644
index 0000000000..0979bd50b6
--- /dev/null
+++ b/resources/function_help/json/sensor_data
@@ -0,0 +1,18 @@
+{
+  "name": "sensor_data",
+  "type": "function",
+  "groups": ["Sensors"],
+  "description": "Returns the last captured value (or values as a map for sensors which report multiple values) from a registered sensor.",
+  "arguments": [{
+    "arg": "name",
+    "description": "the sensor name"
+  },{
+    "arg": "expiration",
+    "description": "maximum millisecond since last captured value allowed",
+    "optional": true
+  }],
+  "examples": [{
+    "expression": "sensor_data('geiger_1')",
+    "returns": "'2000'"
+  }]
+}
diff --git a/src/app/gps/qgsappgpsconnection.cpp b/src/app/gps/qgsappgpsconnection.cpp
index 9553008354..db5b692f35 100644
--- a/src/app/gps/qgsappgpsconnection.cpp
+++ b/src/app/gps/qgsappgpsconnection.cpp
@@ -136,7 +136,7 @@ void QgsAppGpsConnection::connectGps()
         QgisApp::instance()->statusBarIface()->clearMessage();
         showGpsConnectFailureWarning( tr( "No path to the GPS port is specified. Please set a path then try again." ) );
         emit connectionError( tr( "No path to the GPS port is specified. Please set a path then try again." ) );
-        emit statusChanged( Qgis::GpsConnectionStatus::Disconnected );
+        emit statusChanged( Qgis::DeviceConnectionStatus::Disconnected );
         return;
       }
       break;
@@ -148,7 +148,7 @@ void QgsAppGpsConnection::connectGps()
   }
 
   emit connecting();
-  emit statusChanged( Qgis::GpsConnectionStatus::Connecting );
+  emit statusChanged( Qgis::DeviceConnectionStatus::Connecting );
   emit fixStatusChanged( Qgis::GpsFixStatus::NoData );
 
   QgisApp::instance()->statusBarIface()->clearMessage();
@@ -167,7 +167,7 @@ void QgsAppGpsConnection::disconnectGps()
   mConnection = nullptr;
 
   emit disconnected();
-  emit statusChanged( Qgis::GpsConnectionStatus::Disconnected );
+  emit statusChanged( Qgis::DeviceConnectionStatus::Disconnected );
   emit fixStatusChanged( Qgis::GpsFixStatus::NoData );
 
   QgisApp::instance()->statusBarIface()->clearMessage();
@@ -204,7 +204,7 @@ void QgsAppGpsConnection::onConnected( QgsGpsConnection *conn )
   QgsApplication::gpsConnectionRegistry()->registerConnection( mConnection );
 
   emit connected();
-  emit statusChanged( Qgis::GpsConnectionStatus::Connected );
+  emit statusChanged( Qgis::DeviceConnectionStatus::Connected );
   showMessage( Qgis::MessageLevel::Success, tr( "Connected to GPS device." ) );
 }
 
diff --git a/src/app/gps/qgsappgpsconnection.h b/src/app/gps/qgsappgpsconnection.h
index 7a671e997f..9c82af4285 100644
--- a/src/app/gps/qgsappgpsconnection.h
+++ b/src/app/gps/qgsappgpsconnection.h
@@ -105,7 +105,7 @@ class APP_EXPORT QgsAppGpsConnection : public QObject
     /**
      * Emitted when the connection status changes.
      */
-    void statusChanged( Qgis::GpsConnectionStatus status );
+    void statusChanged( Qgis::DeviceConnectionStatus status );
 
     /**
      * Emitted when the GPS device has been disconnected.
diff --git a/src/app/gps/qgsgpsinformationwidget.cpp b/src/app/gps/qgsgpsinformationwidget.cpp
index bed9f84381..5fab417705 100644
--- a/src/app/gps/qgsgpsinformationwidget.cpp
+++ b/src/app/gps/qgsgpsinformationwidget.cpp
@@ -187,21 +187,21 @@ QgsGpsInformationWidget::QgsGpsInformationWidget( QgsAppGpsConnection *connectio
   connect( mConnection, &QgsAppGpsConnection::stateChanged, this, &QgsGpsInformationWidget::displayGPSInformation );
   connect( mConnection, &QgsAppGpsConnection::fixStatusChanged, this, &QgsGpsInformationWidget::setStatusIndicator );
 
-  connect( mConnection, &QgsAppGpsConnection::statusChanged, this, [ = ]( Qgis::GpsConnectionStatus status )
+  connect( mConnection, &QgsAppGpsConnection::statusChanged, this, [ = ]( Qgis::DeviceConnectionStatus status )
   {
     switch ( status )
     {
-      case Qgis::GpsConnectionStatus::Disconnected:
+      case Qgis::DeviceConnectionStatus::Disconnected:
         whileBlocking( mConnectButton )->setChecked( false );
         mConnectButton->setText( tr( "Connect" ) );
         mConnectButton->setEnabled( true );
         break;
-      case Qgis::GpsConnectionStatus::Connecting:
+      case Qgis::DeviceConnectionStatus::Connecting:
         whileBlocking( mConnectButton )->setChecked( true );
         mConnectButton->setText( tr( "Connecting" ) );
         mConnectButton->setEnabled( false );
         break;
-      case Qgis::GpsConnectionStatus::Connected:
+      case Qgis::DeviceConnectionStatus::Connected:
         whileBlocking( mConnectButton )->setChecked( true );
         mConnectButton->setText( tr( "Disconnect" ) );
         mConnectButton->setEnabled( true );
diff --git a/src/app/gps/qgsgpstoolbar.cpp b/src/app/gps/qgsgpstoolbar.cpp
index e20d14f387..63d548ae83 100644
--- a/src/app/gps/qgsgpstoolbar.cpp
+++ b/src/app/gps/qgsgpstoolbar.cpp
@@ -145,11 +145,11 @@ QgsGpsToolBar::QgsGpsToolBar( QgsAppGpsConnection *connection, QgsMapCanvas *can
   mCreateFeatureAction->setEnabled( false );
   mAddTrackVertexAction->setEnabled( false );
   mResetFeatureAction->setEnabled( false );
-  connect( mConnection, &QgsAppGpsConnection::statusChanged, this, [ = ]( Qgis::GpsConnectionStatus status )
+  connect( mConnection, &QgsAppGpsConnection::statusChanged, this, [ = ]( Qgis::DeviceConnectionStatus status )
   {
     switch ( status )
     {
-      case Qgis::GpsConnectionStatus::Disconnected:
+      case Qgis::DeviceConnectionStatus::Disconnected:
         whileBlocking( mConnectAction )->setChecked( false );
         mConnectAction->setText( tr( "Connect GPS" ) );
         mConnectAction->setToolTip( tr( "Connect to GPS" ) );
@@ -161,7 +161,7 @@ QgsGpsToolBar::QgsGpsToolBar( QgsAppGpsConnection *connection, QgsMapCanvas *can
         delete mInformationButton;
         mInformationButton = nullptr;
         break;
-      case Qgis::GpsConnectionStatus::Connecting:
+      case Qgis::DeviceConnectionStatus::Connecting:
         whileBlocking( mConnectAction )->setChecked( true );
         mConnectAction->setToolTip( tr( "Connecting to GPS" ) );
         mConnectAction->setIcon( QgsApplication::getThemeIcon( QStringLiteral( "/gpsicons/mIconGpsConnect.svg" ) ) );
@@ -172,7 +172,7 @@ QgsGpsToolBar::QgsGpsToolBar( QgsAppGpsConnection *connection, QgsMapCanvas *can
         delete mInformationButton;
         mInformationButton = nullptr;
         break;
-      case Qgis::GpsConnectionStatus::Connected:
+      case Qgis::DeviceConnectionStatus::Connected:
         whileBlocking( mConnectAction )->setChecked( true );
         mConnectAction->setText( tr( "Disconnect GPS" ) );
         mConnectAction->setToolTip( tr( "Disconnect from GPS" ) );
diff --git a/src/core/CMakeLists.txt b/src/core/CMakeLists.txt
index 972bcaca07..3061933c35 100644
--- a/src/core/CMakeLists.txt
+++ b/src/core/CMakeLists.txt
@@ -332,6 +332,12 @@ set(QGIS_CORE_SRCS
   textrenderer/qgstextrendererutils.cpp
   textrenderer/qgstextshadowsettings.cpp
 
+  sensor/qgssensormodel.cpp
+  sensor/qgssensormanager.cpp
+  sensor/qgssensorregistry.cpp
+  sensor/qgsabstractsensor.cpp
+  sensor/qgsiodevicesensor.cpp
+
   fromencodedcomponenthelper.cpp
   qgis.cpp
   qgsabstractcontentcache.cpp
@@ -1860,6 +1866,12 @@ set(QGIS_CORE_HDRS
   textrenderer/qgstextrendererutils.h
   textrenderer/qgstextshadowsettings.h
 
+  sensor/qgssensormodel.h
+  sensor/qgssensormanager.h
+  sensor/qgssensorregistry.h
+  sensor/qgsabstractsensor.h
+  sensor/qgsiodevicesensor.h
+
   settings/qgssettings.h
   settings/qgssettingsentry.h
   settings/qgssettingsentrygroup.h
@@ -2220,6 +2232,7 @@ target_include_directories(qgis_core PUBLIC
   renderer
   scalebar
   settings
+  sensor
   symbology
   textrenderer
   validity
diff --git a/src/core/expression/qgsexpressioncontextutils.cpp b/src/core/expression/qgsexpressioncontextutils.cpp
index f2942f7b6b..814971227e 100644
--- a/src/core/expression/qgsexpressioncontextutils.cpp
+++ b/src/core/expression/qgsexpressioncontextutils.cpp
@@ -917,6 +917,7 @@ QgsExpressionContextScope *QgsExpressionContextUtils::notificationScope( const Q
 void QgsExpressionContextUtils::registerContextFunctions()
 {
   QgsExpression::registerFunction( new GetNamedProjectColor( nullptr ) );
+  QgsExpression::registerFunction( new GetSensorData( ) );
   QgsExpression::registerFunction( new GetLayoutItemVariables( nullptr ) );
   QgsExpression::registerFunction( new GetLayoutMapLayerCredits( nullptr ) );
   QgsExpression::registerFunction( new GetLayerVisibility( QList<QgsMapLayer *>(), 0.0 ) );
diff --git a/src/core/project/qgsproject.cpp b/src/core/project/qgsproject.cpp
index 3f0a63fe1c..79574f65f6 100644
--- a/src/core/project/qgsproject.cpp
+++ b/src/core/project/qgsproject.cpp
@@ -69,6 +69,7 @@
 #include "qgscombinedstylemodel.h"
 #include "qgsprojectgpssettings.h"
 #include "qgsthreadingutils.h"
+#include "qgssensormanager.h"
 
 #include <algorithm>
 #include <QApplication>
@@ -375,6 +376,7 @@ QgsProject::QgsProject( QObject *parent, Qgis::ProjectCapabilities capabilities
   , mLayoutManager( new QgsLayoutManager( this ) )
   , m3DViewsManager( new QgsMapViewsManager( this ) )
   , mBookmarkManager( QgsBookmarkManager::createProjectBasedManager( this ) )
+  , mSensorManager( new QgsSensorManager( this ) )
   , mViewSettings( new QgsProjectViewSettings( this ) )
   , mStyleSettings( new QgsProjectStyleSettings( this ) )
   , mTimeSettings( new QgsProjectTimeSettings( this ) )
@@ -1057,6 +1059,7 @@ void QgsProject::clear()
   mLayoutManager->clear();
   m3DViewsManager->clear();
   mBookmarkManager->clear();
+  mSensorManager->clear();
   mViewSettings->reset();
   mTimeSettings->reset();
   mElevationProperties->reset();
@@ -2078,6 +2081,9 @@ bool QgsProject::readProjectFile( const QString &filename, Qgis::ProjectReadFlag
   profile.switchTask( tr( "Loading bookmarks" ) );
   mBookmarkManager->readXml( doc->documentElement(), *doc );
 
+  profile.switchTask( tr( "Loading sensors" ) );
+  mSensorManager->readXml( doc->documentElement(), *doc );
+
   // reassign change dependencies now that all layers are loaded
   QMap<QString, QgsMapLayer *> existingMaps = mapLayers();
   for ( QMap<QString, QgsMapLayer *>::iterator it = existingMaps.begin(); it != existingMaps.end(); ++it )
@@ -2374,9 +2380,14 @@ QgsExpressionContextScope *QgsProject::createExpressionContextScope() const
   if ( mProjectScope )
   {
     std::unique_ptr< QgsExpressionContextScope > projectScope = std::make_unique< QgsExpressionContextScope >( *mProjectScope );
-    // we can't cache these
+
+    // we can't cache these variables
     projectScope->addVariable( QgsExpressionContextScope::StaticVariable( QStringLiteral( "project_distance_units" ), QgsUnitTypes::toString( distanceUnits() ), true, true ) );
     projectScope->addVariable( QgsExpressionContextScope::StaticVariable( QStringLiteral( "project_area_units" ), QgsUnitTypes::toString( areaUnits() ), true, true ) );
+
+    // neither this function
+    projectScope->addFunction( QStringLiteral( "sensor_data" ), new GetSensorData( sensorManager()->sensorsData() ) );
+
     return projectScope.release();
   }
 
@@ -2941,6 +2952,11 @@ bool QgsProject::writeProjectFile( const QString &filename )
     qgisNode.appendChild( bookmarkElem );
   }
 
+  {
+    const QDomElement sensorElem = mSensorManager->writeXml( *doc );
+    qgisNode.appendChild( sensorElem );
+  }
+
   {
     const QDomElement viewSettingsElem = mViewSettings->writeXml( *doc, context );
     qgisNode.appendChild( viewSettingsElem );
@@ -3747,6 +3763,20 @@ QgsBookmarkManager *QgsProject::bookmarkManager()
   return mBookmarkManager;
 }
 
+const QgsSensorManager *QgsProject::sensorManager() const
+{
+  QGIS_PROTECT_QOBJECT_THREAD_ACCESS_NON_FATAL
+
+  return mSensorManager;
+}
+
+QgsSensorManager *QgsProject::sensorManager()
+{
+  QGIS_PROTECT_QOBJECT_THREAD_ACCESS
+
+  return mSensorManager;
+}
+
 const QgsProjectViewSettings *QgsProject::viewSettings() const
 {
   QGIS_PROTECT_QOBJECT_THREAD_ACCESS
@@ -4800,4 +4830,35 @@ QgsScopedExpressionFunction *GetNamedProjectColor::clone() const
 {
   return new GetNamedProjectColor( mColors );
 }
+
+// ----------------
+
+GetSensorData::GetSensorData( const QMap<QString, QgsAbstractSensor::SensorData> &sensorData )
+  : QgsScopedExpressionFunction( QStringLiteral( "sensor_data" ),
+                                 QgsExpressionFunction::ParameterList() << QgsExpressionFunction::Parameter( QStringLiteral( "name" ) ) << QgsExpressionFunction::Parameter( QStringLiteral( "expiration" ), true, 0 ),
+                                 QStringLiteral( "Sensors" ) )
+  , mSensorData( sensorData )
+{
+}
+
+QVariant GetSensorData::func( const QVariantList &values, const QgsExpressionContext *, QgsExpression *, const QgsExpressionNodeFunction * )
+{
+  const QString sensorName = values.at( 0 ).toString();
+  const int expiration = values.at( 1 ).toInt();
+  const qint64 timestamp = QDateTime::currentMSecsSinceEpoch();
+  if ( mSensorData.contains( sensorName ) )
+  {
+    if ( expiration <= 0 || ( timestamp - mSensorData[sensorName].lastTimestamp.toMSecsSinceEpoch() ) < expiration )
+    {
+      return mSensorData[sensorName].lastValue;
+    }
+  }
+
+  return QVariant();
+}
+
+QgsScopedExpressionFunction *GetSensorData::clone() const
+{
+  return new GetSensorData( mSensorData );
+}
 ///@endcond
diff --git a/src/core/project/qgsproject.h b/src/core/project/qgsproject.h
index f0b5f7a027..a6d5fb4a2c 100644
--- a/src/core/project/qgsproject.h
+++ b/src/core/project/qgsproject.h
@@ -53,6 +53,7 @@
 #include "qgspropertycollection.h"
 #include "qgsvectorlayereditbuffergroup.h"
 #include "qgselevationshadingrenderer.h"
+#include "qgsabstractsensor.h"
 
 #include "qgsrelationmanager.h"
 #include "qgsmapthemecollection.h"
@@ -87,6 +88,7 @@ class QgsPropertyCollection;
 class QgsMapViewsManager;
 class QgsProjectElevationProperties;
 class QgsProjectGpsSettings;
+class QgsSensorManager;
 
 /**
  * \ingroup core
@@ -796,6 +798,21 @@ class CORE_EXPORT QgsProject : public QObject, public QgsExpressionContextGenera
      */
     QgsBookmarkManager *bookmarkManager();
 
+    /**
+     * Returns the project's sensor manager, which manages sensors within
+     * the project.
+     * \note not available in Python bindings
+     * \since QGIS 3.32
+     */
+    const QgsSensorManager *sensorManager() const SIP_SKIP;
+
+    /**
+     * Returns the project's sensor manager, which manages sensors within
+     * the project.
+     * \since QGIS 3.32
+     */
+    QgsSensorManager *sensorManager();
+
     /**
      * Returns the project's view settings, which contains settings and properties
      * relating to how a QgsProject should be viewed and behave inside a map canvas
@@ -2275,6 +2292,8 @@ class CORE_EXPORT QgsProject : public QObject, public QgsExpressionContextGenera
 
     QgsBookmarkManager *mBookmarkManager = nullptr;
 
+    QgsSensorManager *mSensorManager = nullptr;
+
     QgsProjectViewSettings *mViewSettings = nullptr;
 
     QgsProjectStyleSettings *mStyleSettings = nullptr;
@@ -2457,6 +2476,17 @@ class GetNamedProjectColor : public QgsScopedExpressionFunction
 
 };
 
+class GetSensorData : public QgsScopedExpressionFunction
+{
+  public:
+    GetSensorData( const QMap<QString, QgsAbstractSensor::SensorData> &sensorData = QMap<QString, QgsAbstractSensor::SensorData>() );
+    QVariant func( const QVariantList &values, const QgsExpressionContext *, QgsExpression *, const QgsExpressionNodeFunction * ) override;
+    QgsScopedExpressionFunction *clone() const override;
+
+  private:
+
+    QMap<QString, QgsAbstractSensor::SensorData> mSensorData;
+};
 #endif
 ///@endcond
 
diff --git a/src/core/qgis.h b/src/core/qgis.h
index 5a7f28d697..3cd175601c 100644
--- a/src/core/qgis.h
+++ b/src/core/qgis.h
@@ -1108,13 +1108,13 @@ class CORE_EXPORT Qgis
      *
      * \since QGIS 3.30
      */
-    enum class GpsConnectionStatus : int
-    {
+    enum class DeviceConnectionStatus SIP_MONKEYPATCH_SCOPEENUM_UNNEST( Qgis, GpsConnectionStatus ) : int
+      {
       Disconnected, //!< Device is disconnected
       Connecting, //!< Device is connecting
       Connected, //!< Device is successfully connected
     };
-    Q_ENUM( GpsConnectionStatus )
+    Q_ENUM( DeviceConnectionStatus )
 
     /**
      * GPS fix status.
diff --git a/src/core/qgsapplication.cpp b/src/core/qgsapplication.cpp
index f324338aa5..cf247af6dd 100644
--- a/src/core/qgsapplication.cpp
+++ b/src/core/qgsapplication.cpp
@@ -84,6 +84,7 @@
 #include "qgscolorrampimpl.h"
 #include "qgsinterval.h"
 #include "qgsgpsconnection.h"
+#include "qgssensorregistry.h"
 
 #include "gps/qgsgpsconnectionregistry.h"
 #include "processing/qgsprocessingregistry.h"
@@ -2475,6 +2476,11 @@ QgsAnnotationItemRegistry *QgsApplication::annotationItemRegistry()
   return members()->mAnnotationItemRegistry;
 }
 
+QgsSensorRegistry *QgsApplication::sensorRegistry()
+{
+  return members()->mSensorRegistry;
+}
+
 QgsGpsConnectionRegistry *QgsApplication::gpsConnectionRegistry()
 {
   return members()->mGpsConnectionRegistry;
@@ -2747,6 +2753,12 @@ QgsApplication::ApplicationMembers::ApplicationMembers()
     mAnnotationItemRegistry->populate();
     profiler->end();
   }
+  {
+    profiler->start( tr( "Setup sensor registry" ) );
+    mSensorRegistry = new QgsSensorRegistry();
+    mSensorRegistry->populate();
+    profiler->end();
+  }
   {
     profiler->start( tr( "Setup 3D symbol registry" ) );
     m3DSymbolRegistry = new Qgs3DSymbolRegistry();
@@ -2824,6 +2836,7 @@ QgsApplication::ApplicationMembers::~ApplicationMembers()
   delete mProcessingRegistry;
   delete mPageSizeRegistry;
   delete mAnnotationItemRegistry;
+  delete mSensorRegistry;
   delete mLayoutItemRegistry;
   delete mPointCloudRendererRegistry;
   delete mRasterRendererRegistry;
diff --git a/src/core/qgsapplication.h b/src/core/qgsapplication.h
index 23fd3248a7..f775702c39 100644
--- a/src/core/qgsapplication.h
+++ b/src/core/qgsapplication.h
@@ -75,6 +75,7 @@ class QgsCoordinateReferenceSystemRegistry;
 class QgsRecentStyleHandler;
 class QgsDatabaseQueryLog;
 class QgsFontManager;
+class QgsSensorRegistry;
 
 /**
  * \ingroup core
@@ -861,6 +862,12 @@ class CORE_EXPORT QgsApplication : public QApplication
      */
     static QgsFontManager *fontManager() SIP_KEEPREFERENCE;
 
+    /**
+     * Returns the application's sensor registry, used for sensor types.
+     * \since QGIS 3.32
+     */
+    static QgsSensorRegistry *sensorRegistry() SIP_KEEPREFERENCE;
+
     /**
      * Returns the application's message log.
      * \since QGIS 3.0
@@ -1171,6 +1178,7 @@ class CORE_EXPORT QgsApplication : public QApplication
       QgsTaskManager *mTaskManager = nullptr;
       QgsLayoutItemRegistry *mLayoutItemRegistry = nullptr;
       QgsAnnotationItemRegistry *mAnnotationItemRegistry = nullptr;
+      QgsSensorRegistry *mSensorRegistry = nullptr;
       QgsUserProfileManager *mUserConfigManager = nullptr;
       QgsBookmarkManager *mBookmarkManager = nullptr;
       QgsTileDownloadManager *mTileDownloadManager = nullptr;
diff --git a/src/core/sensor/qgsabstractsensor.cpp b/src/core/sensor/qgsabstractsensor.cpp
new file mode 100644
index 0000000000..596bb64935
--- /dev/null
+++ b/src/core/sensor/qgsabstractsensor.cpp
@@ -0,0 +1,118 @@
+/***************************************************************************
+                             qgsabstractsensor.cpp
+                             ---------------------------
+    begin                : March 2023
+    copyright            : (C) 2023 by Mathieu Pellerin
+    email                : mathieu at opengis dot ch
+ ***************************************************************************/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "qgsabstractsensor.h"
+
+#include <QUuid>
+
+QgsAbstractSensor::QgsAbstractSensor( QObject *parent )
+  : QObject( parent )
+  , mId( QUuid::createUuid().toString() )
+{
+}
+
+QString QgsAbstractSensor::name() const
+{
+  return mName;
+}
+
+void QgsAbstractSensor::setName( const QString &name )
+{
+  if ( mName == name )
+    return;
+
+  mName = name;
+  emit nameChanged();
+}
+
+Qgis::DeviceConnectionStatus QgsAbstractSensor::status() const
+{
+  return mStatus;
+}
+
+void QgsAbstractSensor::setStatus( Qgis::DeviceConnectionStatus status )
+{
+  if ( mStatus == status )
+    return;
+
+  mStatus = status;
+  emit statusChanged();
+}
+
+QgsAbstractSensor::SensorData QgsAbstractSensor::data() const
+{
+  return mData;
+}
+
+void QgsAbstractSensor::setData( const QgsAbstractSensor::SensorData &data )
+{
+  mData = data;
+  emit dataChanged();
+}
+
+QString QgsAbstractSensor::errorString() const
+{
+  return mErrorString;
+}
+
+void QgsAbstractSensor::connectSensor()
+{
+  setStatus( Qgis::DeviceConnectionStatus::Connecting );
+  handleConnect();
+}
+
+void QgsAbstractSensor::disconnectSensor()
+{
+  handleDisconnect();
+  setStatus( Qgis::DeviceConnectionStatus::Disconnected );
+}
+
+bool QgsAbstractSensor::writePropertiesToElement( QDomElement &, QDomDocument & ) const
+{
+  return true;
+}
+
+bool QgsAbstractSensor::readPropertiesFromElement( const QDomElement &, const QDomDocument & )
+{
+  return true;
+}
+
+bool QgsAbstractSensor::writeXml( QDomElement &parentElement, QDomDocument &document ) const
+{
+  QDomElement element = document.createElement( QStringLiteral( "Sensor" ) );
+  element.setAttribute( QStringLiteral( "id" ), id() );
+  element.setAttribute( QStringLiteral( "type" ), type() );
+  element.setAttribute( QStringLiteral( "name" ), name() );
+
+  writePropertiesToElement( element, document );
+  parentElement.appendChild( element );
+
+  return true;
+}
+
+bool QgsAbstractSensor::readXml( const QDomElement &element, const QDomDocument &document )
+{
+  if ( element.nodeName() != QLatin1String( "Sensor" ) )
+  {
+    return false;
+  }
+
+  mId = element.attribute( QStringLiteral( "id" ), QUuid::createUuid().toString() );
+  mName = element.attribute( QStringLiteral( "name" ) );
+  readPropertiesFromElement( element, document );
+
+  return true;
+}
diff --git a/src/core/sensor/qgsabstractsensor.h b/src/core/sensor/qgsabstractsensor.h
new file mode 100644
index 0000000000..9474f3c88f
--- /dev/null
+++ b/src/core/sensor/qgsabstractsensor.h
@@ -0,0 +1,220 @@
+/***************************************************************************
+                             qgsabstractsensor.h
+                             ---------------------------
+    begin                : March 2023
+    copyright            : (C) 2023 by Mathieu Pellerin
+    email                : mathieu at opengis dot ch
+ ***************************************************************************/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef QGSABSTRACTSENSOR_H
+#define QGSABSTRACTSENSOR_H
+
+#include "qgis_core.h"
+#include "qgis_sip.h"
+#include "qgis.h"
+
+#include <QDateTime>
+#include <QDomElement>
+#include <QVariant>
+
+/**
+ * \ingroup core
+ * \class QgsAbstractSensor
+ * \brief An abstract base class for sensor classes
+ * \since QGIS 3.32
+ */
+class CORE_EXPORT QgsAbstractSensor : public QObject
+{
+#ifdef SIP_RUN
+#include "qgsiodevicesensor.h"
+#include "qgssensorregistry.h"
+#endif
+
+
+#ifdef SIP_RUN
+    SIP_CONVERT_TO_SUBCLASS_CODE
+    if ( QgsAbstractSensor *item = qobject_cast< QgsAbstractSensor * >( sipCpp ) )
+    {
+      if ( item->type() == QLatin1String( "tcp_socket" ) && dynamic_cast<QgsTcpSocketSensor *>( item ) != NULL )
+      {
+        sipType = sipType_QgsTcpSocketSensor;
+      }
+      else if ( item->type() == QLatin1String( "udp_socket" ) && dynamic_cast<QgsUdpSocketSensor *>( item ) != NULL )
+      {
+        sipType = sipType_QgsUdpSocketSensor;
+      }
+      else if ( item->type() == QLatin1String( "serial_port" ) && dynamic_cast<QgsSerialPortSensor *>( item ) != NULL )
+      {
+        sipType = sipType_QgsSerialPortSensor;
+      }
+      else
+      {
+        sipType = sipType_QgsAbstractSensor;
+      }
+    }
+    else
+    {
+      sipType = NULL;
+    }
+    SIP_END
+#endif
+
+    Q_OBJECT
+
+  public:
+
+    /**
+     * Contains details of a sensor data capture
+     */
+    struct CORE_EXPORT SensorData
+    {
+
+      /**
+       * Last captured sensor value stored as a QVariant.
+       * \note The member can store multiple values if the sensor passes on a QVariantMap.
+       */
+      QVariant lastValue;
+
+      //! Timestamp of last captured sensor value
+      QDateTime lastTimestamp;
+    };
+
+    /**
+     * Constructor for an abstract sensor, bound to the specified \a parent.
+     */
+    explicit QgsAbstractSensor( QObject *parent SIP_TRANSFERTHIS = nullptr );
+    virtual ~QgsAbstractSensor() = default;
+
+    /**
+     * Returns the sensor ID.
+     * \note This is a autogenerated unique string identifying an individual sensor.
+     */
+    QString id() const { return mId; }
+
+    /**
+     * Returns the sensor type. This will match the type string of the sensor class, as used by QgsSensorRegistry.
+     */
+    virtual QString type() const { return QString(); }
+
+    /**
+     * Returns the user-friendly name identifying the sensor.
+     */
+    QString name() const;
+
+    /**
+     * Sets the  user-friendly name identfying the sensor.
+     */
+    void setName( const QString &name );
+
+    /**
+     * Returns the current sensor status.
+     */
+    Qgis::DeviceConnectionStatus status() const;
+
+    /**
+     * Sets the current sensor \a status.
+     */
+    void setStatus( Qgis::DeviceConnectionStatus status );
+
+    /**
+     * Connects the sensor to its source.
+     */
+    void connectSensor();
+
+    /**
+     * Disconnects the sensor from its source.
+     */
+    void disconnectSensor();
+
+    /**
+     * Returns the latest captured data from the sensor.
+     */
+    QgsAbstractSensor::SensorData data() const;
+
+    /**
+     * Sets the latest captured data from the sensor.
+     */
+    void setData( const QgsAbstractSensor::SensorData &data );
+
+    /**
+     * Returns the last error message.
+     */
+    QString errorString() const;
+
+    /**
+     * Write generic sensor properties into a DOM element.
+     * \param parentElement parent DOM element (e.g 'Sensors' element)
+     * \param document DOM document
+     */
+    bool writeXml( QDomElement &parentElement, QDomDocument &document ) const;
+
+    /**
+     * Restores generic sensor details from a DOM element.
+     * \param element DOM node corresponding to item (e.g. 'Sensor' element)
+     * \param document DOM document
+     */
+    bool readXml( const QDomElement &element, const QDomDocument &document );
+
+    /**
+     * Write specific sensor type properties into a DOM element.
+     * \param element  DOM node corresponding to item (e.g. 'Sensor' element)
+     * \param document DOM document
+     */
+    virtual bool writePropertiesToElement( QDomElement &element, QDomDocument &document ) const;
+
+    /**
+     * Restores specific sensor type properties from a DOM element.
+     * \param element  DOM node corresponding to item (e.g. 'Sensor' element)
+     * \param document DOM document
+     */
+    virtual bool readPropertiesFromElement( const QDomElement &element, const QDomDocument &document );
+
+  signals:
+
+    //! Emitted when the sensor name has changed.
+    void nameChanged();
+
+    //! Emitted when the sensor status has changed.
+    void statusChanged();
+
+    //! Emitted when the captured sensor data has changed.
+    void dataChanged();
+
+    //! Emitted when an error has occurred. The \a errorString describes the error.
+    void errorOccurred( const QString &errorString );
+
+  protected:
+
+    /**
+     * Handles the connection to the sensor.
+     * \note Triggered by calling connectSensor()
+     */
+    virtual void handleConnect() = 0;
+
+    /**
+     * Handles the disconnection from the sensor.
+     * \note Triggered by calling disconnectSensor()
+     */
+    virtual void handleDisconnect() = 0;
+
+    QgsAbstractSensor::SensorData mData;
+    QString mErrorString;
+
+  private:
+
+    QString mId;
+    QString mName;
+    Qgis::DeviceConnectionStatus mStatus = Qgis::DeviceConnectionStatus::Disconnected;
+
+};
+
+Q_DECLARE_METATYPE( QgsAbstractSensor * )
+
+#endif //QGSABSTRACTSENSOR_H
diff --git a/src/core/sensor/qgsiodevicesensor.cpp b/src/core/sensor/qgsiodevicesensor.cpp
new file mode 100644
index 0000000000..8c28fb2c31
--- /dev/null
+++ b/src/core/sensor/qgsiodevicesensor.cpp
@@ -0,0 +1,423 @@
+/***************************************************************************
+                             qgsiodevicesensor.cpp
+                             ---------------------------
+    begin                : March 2023
+    copyright            : (C) 2023 by Mathieu Pellerin
+    email                : mathieu at opengis dot ch
+ ***************************************************************************/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "qgsiodevicesensor.h"
+#include "qgssensorregistry.h"
+
+#include <QDomElement>
+
+#if defined( Q_OS_ANDROID ) || defined( Q_OS_LINUX )
+#include <sys/socket.h>
+#endif
+
+QgsIODeviceSensor::~QgsIODeviceSensor()
+{
+}
+
+void QgsIODeviceSensor::initIODevice( QIODevice *device )
+{
+  mIODevice.reset( device );
+
+  if ( mIODevice )
+  {
+    connect( mIODevice.get(), &QIODevice::readyRead, this, &QgsIODeviceSensor::parseData );
+  }
+}
+
+QIODevice *QgsIODeviceSensor::iODevice() const
+{
+  return mIODevice.get();
+}
+
+void QgsIODeviceSensor::parseData()
+{
+  QgsAbstractSensor::SensorData data;
+  data.lastValue = mIODevice->readAll();
+  data.lastTimestamp = QDateTime::currentDateTime();
+  setData( data );
+}
+
+//--------------
+
+QgsTcpSocketSensor::QgsTcpSocketSensor( QObject *parent )
+  : QgsIODeviceSensor( parent )
+  , mTcpSocket( new QTcpSocket() )
+{
+  connect( mTcpSocket, &QAbstractSocket::stateChanged, this, &QgsTcpSocketSensor::socketStateChanged );
+
+#if QT_VERSION < QT_VERSION_CHECK( 5, 15, 0 )
+  connect( mTcpSocket, qOverload<QAbstractSocket::SocketError>( &QAbstractSocket::error ), this, &QgsTcpSocketSensor::handleError );
+#else
+  connect( mTcpSocket, qOverload<QAbstractSocket::SocketError>( &QAbstractSocket::errorOccurred ), this, &QgsTcpSocketSensor::handleError );
+#endif
+
+  initIODevice( mTcpSocket );
+}
+
+QgsTcpSocketSensor *QgsTcpSocketSensor::create( QObject *parent )
+{
+  return new QgsTcpSocketSensor( parent );
+}
+
+QString QgsTcpSocketSensor::type() const
+{
+  return QLatin1String( "tcp_socket" );
+}
+
+QString QgsTcpSocketSensor::hostName() const
+{
+  return mHostName;
+}
+
+void QgsTcpSocketSensor::setHostName( const QString &hostName )
+{
+  if ( mHostName == hostName )
+    return;
+
+  mHostName = hostName;
+}
+
+int QgsTcpSocketSensor::port() const
+{
+  return mPort;
+}
+
+void QgsTcpSocketSensor::setPort( int port )
+{
+  if ( mPort == port || port < 1 )
+    return;
+
+  mPort = port;
+}
+
+void QgsTcpSocketSensor::handleConnect()
+{
+  if ( mHostName.isEmpty() || mPort == 0 )
+  {
+    setStatus( Qgis::DeviceConnectionStatus::Disconnected );
+    return;
+  }
+
+  mTcpSocket->connectToHost( mHostName, mPort, QTcpSocket::ReadOnly );
+}
+
+void QgsTcpSocketSensor::handleDisconnect()
+{
+  mTcpSocket->close();
+}
+
+void QgsTcpSocketSensor::handleError( QAbstractSocket::SocketError error )
+{
+  switch ( error )
+  {
+    case QAbstractSocket::HostNotFoundError:
+      mErrorString = tr( "Could not find the remote host" );
+      break;
+    case QAbstractSocket::NetworkError:
+      mErrorString = tr( "Attempt to read or write from socket returned an error" );
+      break;
+    case QAbstractSocket::ConnectionRefusedError:
+      mErrorString = tr( "The connection was refused by the remote host" );
+      break;
+    default:
+      mErrorString = tr( "%1" ).arg( QMetaEnum::fromType<QAbstractSocket::SocketError>().valueToKey( error ) );
+      break;
+  }
+
+  emit errorOccurred( mErrorString );
+}
+
+void QgsTcpSocketSensor::socketStateChanged( const QAbstractSocket::SocketState socketState )
+{
+  switch ( socketState )
+  {
+    case QAbstractSocket::ConnectedState:
+    {
+      setStatus( Qgis::DeviceConnectionStatus::Connected );
+      break;
+    }
+    case QAbstractSocket::UnconnectedState:
+    {
+      setStatus( Qgis::DeviceConnectionStatus::Disconnected );
+      break;
+    }
+    default:
+      break;
+  }
+}
+
+bool QgsTcpSocketSensor::writePropertiesToElement( QDomElement &element, QDomDocument & ) const
+{
+  element.setAttribute( QStringLiteral( "hostName" ), mHostName );
+  element.setAttribute( QStringLiteral( "port" ), QString::number( mPort ) );
+
+  return true;
+}
+
+bool QgsTcpSocketSensor::readPropertiesFromElement( const QDomElement &element, const QDomDocument & )
+{
+  mHostName = element.attribute( QStringLiteral( "hostName" ) );
+  mPort = element.attribute( QStringLiteral( "port" ) ).toInt();
+
+  return true;
+}
+
+//--------------
+
+QgsUdpSocketSensor::QgsUdpSocketSensor( QObject *parent )
+  : QgsIODeviceSensor( parent )
+  , mUdpSocket( std::make_unique<QUdpSocket>() )
+  , mBuffer( new QBuffer() )
+{
+#if defined( Q_OS_ANDROID ) || defined( Q_OS_LINUX )
+  int sockfd = socket( AF_INET, SOCK_DGRAM, 0 );
+  int optval = 1;
+  setsockopt( sockfd, SOL_SOCKET, SO_REUSEADDR,
+              ( void * ) &optval, sizeof( optval ) );
+  mUdpSocket->setSocketDescriptor( sockfd, QUdpSocket::UnconnectedState );
+#endif
+
+  connect( mUdpSocket.get(), &QAbstractSocket::stateChanged, this, &QgsUdpSocketSensor::socketStateChanged );
+  connect( mUdpSocket.get(), &QUdpSocket::readyRead, this, [ = ]()
+  {
+    QByteArray datagram;
+    while ( mUdpSocket->hasPendingDatagrams() )
+    {
+      datagram.resize( int( mUdpSocket->pendingDatagramSize() ) );
+      mUdpSocket->readDatagram( datagram.data(), datagram.size() );
+
+      mBuffer->buffer().clear();
+      mBuffer->seek( 0 );
+      mBuffer->write( datagram );
+      mBuffer->seek( 0 );
+    }
+  } );
+
+#if QT_VERSION < QT_VERSION_CHECK( 5, 15, 0 )
+  connect( mUdpSocket.get(), qOverload<QAbstractSocket::SocketError>( &QAbstractSocket::error ), this, &QgsUdpSocketSensor::handleError );
+#else
+  connect( mUdpSocket.get(), qOverload<QAbstractSocket::SocketError>( &QAbstractSocket::errorOccurred ), this, &QgsUdpSocketSensor::handleError );
+#endif
+
+  initIODevice( mBuffer );
+}
+
+QgsUdpSocketSensor *QgsUdpSocketSensor::create( QObject *parent )
+{
+  return new QgsUdpSocketSensor( parent );
+}
+
+QString QgsUdpSocketSensor::type() const
+{
+  return QLatin1String( "udp_socket" );
+}
+
+QString QgsUdpSocketSensor::hostName() const
+{
+  return mHostName;
+}
+
+void QgsUdpSocketSensor::setHostName( const QString &hostName )
+{
+  if ( mHostName == hostName )
+    return;
+
+  mHostName = hostName;
+}
+
+int QgsUdpSocketSensor::port() const
+{
+  return mPort;
+}
+
+void QgsUdpSocketSensor::setPort( int port )
+{
+  if ( mPort == port || port < 1 )
+    return;
+
+  mPort = port;
+}
+
+void QgsUdpSocketSensor::handleConnect()
+{
+  if ( mHostName.isEmpty() || mPort == 0 )
+  {
+    setStatus( Qgis::DeviceConnectionStatus::Disconnected );
+    return;
+  }
+
+  mBuffer->open( QIODevice::ReadWrite );
+  mUdpSocket->bind( QHostAddress( mHostName ), mPort, QAbstractSocket::ShareAddress | QAbstractSocket::ReuseAddressHint );
+  mUdpSocket->joinMulticastGroup( QHostAddress( mHostName ) );
+}
+
+void QgsUdpSocketSensor::handleDisconnect()
+{
+  mUdpSocket->close();
+  mBuffer->close();
+}
+
+void QgsUdpSocketSensor::handleError( QAbstractSocket::SocketError error )
+{
+  switch ( error )
+  {
+    case QAbstractSocket::HostNotFoundError:
+      mErrorString = tr( "Could not find the remote host" );
+      break;
+    case QAbstractSocket::NetworkError:
+      mErrorString = tr( "Attempt to read or write from socket returned an error" );
+      break;
+    case QAbstractSocket::ConnectionRefusedError:
+      mErrorString = tr( "The connection was refused by the remote host" );
+      break;
+    default:
+      mErrorString = tr( "%1" ).arg( QMetaEnum::fromType<QAbstractSocket::SocketError>().valueToKey( error ) );
+      break;
+  }
+
+  emit errorOccurred( mErrorString );
+}
+
+void QgsUdpSocketSensor::socketStateChanged( const QAbstractSocket::SocketState socketState )
+{
+  switch ( socketState )
+  {
+    case QAbstractSocket::ConnectedState:
+    case QAbstractSocket::BoundState:
+    {
+      setStatus( Qgis::DeviceConnectionStatus::Connected );
+      break;
+    }
+    case QAbstractSocket::UnconnectedState:
+    {
+      setStatus( Qgis::DeviceConnectionStatus::Disconnected );
+      break;
+    }
+    default:
+      break;
+  }
+}
+
+bool QgsUdpSocketSensor::writePropertiesToElement( QDomElement &element, QDomDocument & ) const
+{
+  element.setAttribute( QStringLiteral( "hostName" ), mHostName );
+  element.setAttribute( QStringLiteral( "port" ), QString::number( mPort ) );
+
+  return true;
+}
+
+bool QgsUdpSocketSensor::readPropertiesFromElement( const QDomElement &element, const QDomDocument & )
+{
+  mHostName = element.attribute( QStringLiteral( "hostName" ) );
+  mPort = element.attribute( QStringLiteral( "port" ) ).toInt();
+
+  return true;
+}
+
+//--------------
+
+#if defined( HAVE_QTSERIALPORT )
+QgsSerialPortSensor::QgsSerialPortSensor( QObject *parent )
+  : QgsIODeviceSensor( parent )
+  , mSerialPort( new QSerialPort() )
+{
+  connect( mSerialPort, qOverload<QSerialPort::SerialPortError>( &QSerialPort::errorOccurred ), this, &QgsSerialPortSensor::handleError );
+
+  initIODevice( mSerialPort );
+}
+
+QgsSerialPortSensor *QgsSerialPortSensor::create( QObject *parent )
+{
+  return new QgsSerialPortSensor( parent );
+}
+
+QString QgsSerialPortSensor::type() const
+{
+  return QLatin1String( "serial_port" );
+}
+
+QString QgsSerialPortSensor::portName() const
+{
+  return mPortName;
+}
+
+void QgsSerialPortSensor::setPortName( const QString &portName )
+{
+  if ( mPortName == portName )
+    return;
+
+  mPortName = portName;
+}
+
+void QgsSerialPortSensor::handleConnect()
+{
+  mSerialPort->setPortName( mPortName );
+  mSerialPort->setBaudRate( QSerialPort::Baud9600 );
+  if ( mSerialPort->open( QIODevice::ReadOnly ) )
+  {
+    setStatus( Qgis::DeviceConnectionStatus::Connected );
+  }
+  else
+  {
+    setStatus( Qgis::DeviceConnectionStatus::Disconnected );
+  }
+}
+
+void QgsSerialPortSensor::handleDisconnect()
+{
+  mSerialPort->close();
+}
+
+void QgsSerialPortSensor::handleError( QSerialPort::SerialPortError error )
+{
+  if ( error == QSerialPort::NoError )
+  {
+    return;
+  }
+
+  switch ( error )
+  {
+    case QSerialPort::DeviceNotFoundError:
+      mErrorString = tr( "Could not find the serial port device" );
+      break;
+    case QSerialPort::ReadError:
+      mErrorString = tr( "Attempt to read from the serial port returned an error" );
+      break;
+    case QSerialPort::PermissionError:
+      mErrorString = tr( "The connection was refused due to not having enough permission" );
+      break;
+    default:
+      mErrorString = tr( "%1" ).arg( QMetaEnum::fromType<QSerialPort::SerialPortError>().valueToKey( error ) );
+      break;
+  }
+
+  emit errorOccurred( mErrorString );
+}
+
+bool QgsSerialPortSensor::writePropertiesToElement( QDomElement &element, QDomDocument & ) const
+{
+  element.setAttribute( QStringLiteral( "portName" ), mPortName );
+
+  return true;
+}
+
+bool QgsSerialPortSensor::readPropertiesFromElement( const QDomElement &element, const QDomDocument & )
+{
+  mPortName = element.attribute( QStringLiteral( "portName" ) );
+
+  return true;
+}
+#endif
diff --git a/src/core/sensor/qgsiodevicesensor.h b/src/core/sensor/qgsiodevicesensor.h
new file mode 100644
index 0000000000..690b67f2dc
--- /dev/null
+++ b/src/core/sensor/qgsiodevicesensor.h
@@ -0,0 +1,287 @@
+/***************************************************************************
+                             qgsiodevicesensor.h
+                             ---------------------------
+    begin                : March 2023
+    copyright            : (C) 2023 by Mathieu Pellerin
+    email                : mathieu at opengis dot ch
+ ***************************************************************************/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef QGSIODEVICESENSOR_H
+#define QGSIODEVICESENSOR_H
+
+#include "qgsconfig.h"
+
+#include "qgis_core.h"
+#include "qgis_sip.h"
+#include "qgsabstractsensor.h"
+
+#include <QBuffer>
+#include <QDomElement>
+#include <QTcpSocket>
+#include <QUdpSocket>
+
+#if defined( HAVE_QTSERIALPORT )
+#include <QSerialPort>
+#endif
+
+/**
+ * \ingroup core
+ * \class QgsIODeviceSensor
+ * \brief An abstract class QIODevice-based sensor classes
+ * \since QGIS 3.32
+ */
+class CORE_EXPORT QgsIODeviceSensor : public QgsAbstractSensor
+{
+
+    Q_OBJECT
+
+  public:
+
+    /**
+     * Constructor for a abstract QIODevice-based sensor, bound to the specified \a parent.
+     */
+    explicit QgsIODeviceSensor( QObject *parent = nullptr ) : QgsAbstractSensor( parent ) {}
+    ~QgsIODeviceSensor() override;
+
+    /**
+     * Returns the I/O device.
+     */
+    QIODevice *iODevice() const;
+
+  protected:
+
+    /**
+     * Initiates the I/O \a device.
+     * \note Takes ownership of the device.
+     */
+    void initIODevice( QIODevice *device SIP_TRANSFER );
+
+  protected slots:
+
+    /**
+     * Parses the data read from the device when available.
+     */
+    virtual void parseData();
+
+  private:
+
+    std::unique_ptr<QIODevice> mIODevice;
+
+};
+
+/**
+ * \ingroup core
+ * \class QgsTcpSocketSensor
+ * \brief A TCP socket sensor class
+ * \since QGIS 3.32
+ */
+class CORE_EXPORT QgsTcpSocketSensor : public QgsIODeviceSensor
+{
+
+    Q_OBJECT
+
+  public:
+
+    /**
+     * Constructor for a TCP socket sensor, bound to the specified \a parent.
+     */
+    explicit QgsTcpSocketSensor( QObject *parent = nullptr );
+    ~QgsTcpSocketSensor() override = default;
+
+    /**
+     * Returns a new TCP socket sensor.
+     *
+     * The caller takes responsibility for deleting the returned object.
+     */
+    static QgsTcpSocketSensor *create( QObject *parent ) SIP_FACTORY;
+
+    QString type() const override;
+
+    /**
+     * Returns the host name the socket connects to.
+     */
+    QString hostName() const;
+
+    /**
+     * Sets the host name the socket connects to.
+     * \param hostName the host name string (a domain name or an IP address)
+     */
+    void setHostName( const QString &hostName );
+
+    /**
+     * Returns the port the socket connects to.
+     */
+    int port() const;
+
+    /**
+     * Sets the \a port the socket connects to.
+     */
+    void setPort( int port );
+
+    bool writePropertiesToElement( QDomElement &element, QDomDocument &document ) const override;
+    bool readPropertiesFromElement( const QDomElement &element, const QDomDocument &document ) override;
+
+  protected:
+
+    void handleConnect() override;
+    void handleDisconnect() override;
+
+  private slots:
+
+    void socketStateChanged( const QAbstractSocket::SocketState socketState );
+    void handleError( QAbstractSocket::SocketError error );
+
+  private:
+
+    QTcpSocket *mTcpSocket = nullptr;
+
+    QString mHostName;
+    int mPort = 0;
+
+};
+
+/**
+ * \ingroup core
+ * \class QgsUdpSocketSensor
+ * \brief A UDP socket sensor class
+ * \since QGIS 3.32
+ */
+class CORE_EXPORT QgsUdpSocketSensor : public QgsIODeviceSensor
+{
+
+    Q_OBJECT
+
+  public:
+
+    /**
+     * Constructor for a UDP socket sensor, bound to the specified \a parent.
+     */
+    explicit QgsUdpSocketSensor( QObject *parent = nullptr );
+    ~QgsUdpSocketSensor() override = default;
+
+    /**
+     * Returns a new UDP socket sensor.
+     *
+     * The caller takes responsibility for deleting the returned object.
+     */
+    static QgsUdpSocketSensor *create( QObject *parent ) SIP_FACTORY;
+
+    QString type() const override;
+
+    /**
+     * Returns the host name the socket connects to.
+     */
+    QString hostName() const;
+
+    /**
+     * Sets the host name the socket connects to.
+     * \param hostName the host name string (a domain name or an IP address)
+     */
+    void setHostName( const QString &hostName );
+
+    /**
+     * Returns the port the socket connects to.
+     */
+    int port() const;
+
+    /**
+     * Sets the \a port the socket connects to.
+     */
+    void setPort( int port );
+
+    bool writePropertiesToElement( QDomElement &element, QDomDocument &document ) const override;
+    bool readPropertiesFromElement( const QDomElement &element, const QDomDocument &document ) override;
+
+  protected:
+
+    void handleConnect() override;
+    void handleDisconnect() override;
+
+  private slots:
+
+    void socketStateChanged( const QAbstractSocket::SocketState socketState );
+    void handleError( QAbstractSocket::SocketError error );
+
+  private:
+
+    std::unique_ptr<QUdpSocket> mUdpSocket;
+    QBuffer *mBuffer = nullptr;
+
+    QString mHostName;
+    int mPort = 0;
+
+};
+
+#if defined( HAVE_QTSERIALPORT )
+
+/**
+ * \ingroup core
+ * \class QgsSerialPortSensor
+ * \brief A serial port sensor class
+ * \since QGIS 3.32
+ */
+class CORE_EXPORT QgsSerialPortSensor : public QgsIODeviceSensor
+{
+
+    Q_OBJECT
+
+  public:
+
+    /**
+     * Constructor for a serial port sensor, bound to the specified \a parent.
+     */
+    explicit QgsSerialPortSensor( QObject *parent = nullptr );
+    ~QgsSerialPortSensor() override = default;
+
+    /**
+     * Returns a new serial port sensor.
+     *
+     * The caller takes responsibility for deleting the returned object.
+     */
+    static QgsSerialPortSensor *create( QObject *parent ) SIP_FACTORY;
+
+    QString type() const override;
+
+    /**
+     * Returns the serial port the sensor connects to.
+     */
+    QString portName() const;
+
+    /**
+     * Sets the serial port the sensor connects to.
+     * \param portName the port name (e.g. COM4)
+     */
+    void setPortName( const QString &portName );
+
+    bool writePropertiesToElement( QDomElement &element, QDomDocument &document ) const override;
+    bool readPropertiesFromElement( const QDomElement &element, const QDomDocument &document ) override;
+
+  protected:
+
+    void handleConnect() override;
+    void handleDisconnect() override;
+
+  private slots:
+
+    void handleError( QSerialPort::SerialPortError error );
+
+  private:
+
+    QSerialPort *mSerialPort = nullptr;
+
+    QString mPortName;
+
+};
+#endif
+
+#endif //QGSIODEVICESENSOR_H
+
+
+
diff --git a/src/core/sensor/qgssensormanager.cpp b/src/core/sensor/qgssensormanager.cpp
new file mode 100644
index 0000000000..ce1d50c283
--- /dev/null
+++ b/src/core/sensor/qgssensormanager.cpp
@@ -0,0 +1,198 @@
+/***************************************************************************
+    qgssensormanager.cpp
+    ------------------
+    Date                 : March 2023
+    Copyright            : (C) 2023 Mathieu Pellerin
+    Email                : mathieu at opengis dot ch
+ ***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "qgssensormanager.h"
+
+#include "qgsapplication.h"
+#include "qgssensorregistry.h"
+
+QgsSensorManager::QgsSensorManager( QObject *parent )
+  : QObject( parent )
+{
+}
+
+QgsSensorManager::~QgsSensorManager()
+{
+  clear();
+}
+
+void QgsSensorManager::clear()
+{
+  const QList<QgsAbstractSensor *> sensors = mSensors;
+  for ( QgsAbstractSensor *sensor : sensors )
+  {
+    if ( sensor )
+    {
+      removeSensor( sensor->id() );
+    }
+  }
+  mSensors.clear();
+  mSensorsData.clear();
+}
+
+QList<QgsAbstractSensor *> QgsSensorManager::sensors() const
+{
+  return mSensors;
+}
+
+QgsAbstractSensor *QgsSensorManager::sensor( const QString &id ) const
+{
+  for ( QgsAbstractSensor *sensor : mSensors )
+  {
+    if ( sensor->id() == id )
+    {
+      return sensor;
+    }
+  }
+
+  return nullptr;
+}
+
+QgsAbstractSensor::SensorData QgsSensorManager::sensorData( const QString &name ) const
+{
+  return mSensorsData.value( name );
+}
+
+QMap<QString, QgsAbstractSensor::SensorData> QgsSensorManager::sensorsData() const
+{
+  return mSensorsData;
+}
+
+QStringList QgsSensorManager::sensorNames() const
+{
+  QStringList names;
+  for ( const QgsAbstractSensor *sensor : std::as_const( mSensors ) )
+  {
+    names << sensor->name();
+  }
+  return names;
+}
+
+void QgsSensorManager::addSensor( QgsAbstractSensor *sensor )
+{
+  if ( !sensor || mSensors.contains( sensor ) )
+    return;
+
+  connect( sensor, &QgsAbstractSensor::nameChanged, this, &QgsSensorManager::handleSensorNameChanged );
+  connect( sensor, &QgsAbstractSensor::statusChanged, this, &QgsSensorManager::handleSensorStatusChanged );
+  connect( sensor, &QgsAbstractSensor::dataChanged, this, &QgsSensorManager::captureSensorData );
+  connect( sensor, &QgsAbstractSensor::errorOccurred, this, &QgsSensorManager::handleSensorErrorOccurred );
+  mSensors << sensor;
+
+  emit sensorAdded( sensor->id() );
+
+  return;
+}
+
+bool QgsSensorManager::removeSensor( const QString &id )
+{
+  for ( QgsAbstractSensor *sensor : mSensors )
+  {
+    if ( sensor->id() == id )
+    {
+      emit sensorAboutToBeRemoved( id );
+      mSensors.removeAll( sensor );
+      mSensorsData.remove( sensor->name() );
+      sensor->disconnectSensor();
+      sensor->deleteLater();
+      emit sensorRemoved( id );
+      return true;
+    }
+  }
+
+  return false;
+}
+
+void QgsSensorManager::handleSensorNameChanged()
+{
+  const QgsAbstractSensor *sensor = qobject_cast<QgsAbstractSensor *>( sender() );
+  if ( !sensor )
+    return;
+
+  emit sensorNameChanged( sensor->id() );
+}
+
+void QgsSensorManager::handleSensorStatusChanged()
+{
+  const QgsAbstractSensor *sensor = qobject_cast<QgsAbstractSensor *>( sender() );
+  if ( !sensor )
+    return;
+
+  if ( sensor->status() == Qgis::DeviceConnectionStatus::Disconnected )
+  {
+    mSensorsData.remove( sensor->name() );
+  }
+
+  emit sensorStatusChanged( sensor->id() );
+}
+
+void QgsSensorManager::captureSensorData()
+{
+  const QgsAbstractSensor *sensor = qobject_cast<QgsAbstractSensor *>( sender() );
+  if ( !sensor )
+    return;
+
+  mSensorsData.insert( sensor->name(), sensor->data() );
+  emit sensorDataCaptured( sensor->id() );
+}
+
+void QgsSensorManager::handleSensorErrorOccurred( const QString & )
+{
+  const QgsAbstractSensor *sensor = qobject_cast<QgsAbstractSensor *>( sender() );
+  if ( !sensor )
+    return;
+
+  emit sensorErrorOccurred( sensor->id() );
+}
+
+bool QgsSensorManager::readXml( const QDomElement &element, const QDomDocument &document )
+{
+  clear();
+
+  QDomElement sensorsElem = element;
+  if ( element.tagName() != QLatin1String( "Sensors" ) )
+  {
+    sensorsElem = element.firstChildElement( QStringLiteral( "Sensors" ) );
+  }
+
+  QDomNodeList sensorNodes = element.elementsByTagName( QStringLiteral( "Sensor" ) );
+  for ( int i = 0; i < sensorNodes.size(); ++i )
+  {
+    const QDomElement sensorElement = sensorNodes.at( i ).toElement();
+    const QString sensorType = sensorElement.attribute( QStringLiteral( "type" ) );
+    QgsAbstractSensor *sensor = QgsApplication::sensorRegistry()->createSensor( sensorType, this );
+    if ( !sensor )
+    {
+      continue;
+    }
+
+    sensor->readXml( sensorElement, document );
+    addSensor( sensor );
+  }
+
+  return true;
+}
+
+QDomElement QgsSensorManager::writeXml( QDomDocument &document ) const
+{
+  QDomElement sensorsElem = document.createElement( QStringLiteral( "Sensors" ) );
+
+  for ( const QgsAbstractSensor *sensor : mSensors )
+  {
+    sensor->writeXml( sensorsElem, document );
+  }
+
+  return sensorsElem;
+}
diff --git a/src/core/sensor/qgssensormanager.h b/src/core/sensor/qgssensormanager.h
new file mode 100644
index 0000000000..7bd48058e7
--- /dev/null
+++ b/src/core/sensor/qgssensormanager.h
@@ -0,0 +1,151 @@
+/***************************************************************************
+    qgssensormanager.h
+    ------------------
+    Date                 : March 2023
+    Copyright            : (C) 2023 Mathieu Pellerin
+    Email                : mathieu at opengis dot ch
+ ***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef QGSSENSORMANAGER_H
+#define QGSSENSORMANAGER_H
+
+#include "qgis_core.h"
+#include "qgis_sip.h"
+#include "qgis.h"
+#include "qgsabstractsensor.h"
+
+#include <QObject>
+#include <QDomElement>
+
+class QgsProject;
+
+/**
+ * \ingroup core
+ * \class QgsSensorManager
+ *
+ * \brief Manages sensors.
+ *
+ * QgsSensorManager handles the storage, serializing and deserializing
+ * of sensors. Usually this class is not constructed directly, but
+ * rather accessed through a QgsProject via QgsProject::sensorManager().
+ *
+ * \since QGIS 3.32
+ */
+class CORE_EXPORT QgsSensorManager : public QObject
+{
+    Q_OBJECT
+
+  public:
+
+    /**
+     * Constructor for QgsSensorManager, with the specified \a parent object.
+     */
+    explicit QgsSensorManager( QObject *parent SIP_TRANSFERTHIS = nullptr );
+
+    ~QgsSensorManager() override;
+
+    /**
+     * Deregisters and removes all sensors from the manager.
+     */
+    void clear();
+
+    /**
+     * Returns a list of pointers to all registered sensors.
+     */
+    QList<QgsAbstractSensor *> sensors() const;
+
+    /**
+     * Returns a registered sensor pointer matching a given \a id. If not
+     * matching sensor is found, a NULLPTR will be returned.
+     */
+    QgsAbstractSensor *sensor( const QString &id ) const;
+
+    /**
+     * Registers a new \a sensor.
+     * The sensor name does not require uniqueness; sensors will the same
+     * name will store their data in the same sensor name key, allowing for
+     * registration of sensors to cover multiple devices (e.g. two serial port
+     * sensors with alternative port name to cover two machines).
+     * \note Takes ownership of the sensor.
+     */
+    void addSensor( QgsAbstractSensor *sensor SIP_TRANSFER );
+
+    /**
+     * Removes a registered sensor matching a given \a id.
+     * \returns TRUE if a sensor was removed.
+     */
+    bool removeSensor( const QString &id );
+
+    /**
+     * Returns a list of registered sensor names.
+     */
+    QStringList sensorNames() const;
+
+    /**
+     * Returns the last captured data from a registered sensor matching a given \a name.
+     */
+    QgsAbstractSensor::SensorData sensorData( const QString &name ) const;
+
+    /**
+     * Returns the last captured data of all registered sensors.
+     */
+    QMap<QString, QgsAbstractSensor::SensorData> sensorsData() const;
+
+    /**
+     * Reads the manager's state from a DOM element, restoring all sensors
+     * present in the XML document.
+     * \see writeXml()
+     */
+    bool readXml( const QDomElement &element, const QDomDocument &document );
+
+    /**
+     * Returns a DOM element representing the state of the manager.
+     * \see readXml()
+     */
+    QDomElement writeXml( QDomDocument &document ) const;
+
+  signals:
+
+    //! Emitted when a sensor has been registered.
+    void sensorAdded( const QString &id );
+
+    //! Emitted when a sensor is about to be removed.
+    void sensorAboutToBeRemoved( const QString &id );
+
+    //! Emitted when a sensor has been removed.
+    void sensorRemoved( const QString &id );
+
+    //! Emitted when a sensor name has changed.
+    void sensorNameChanged( const QString &id );
+
+    //! Emitted when a sensor status has changed.
+    void sensorStatusChanged( const QString &id );
+
+    //! Emitted when newly captured data from a sensor has occurred.
+    void sensorDataCaptured( const QString &id );
+
+    //! Emitted when a sensor error has occurred.
+    void sensorErrorOccurred( const QString &id );
+
+  private slots:
+
+    void handleSensorNameChanged();
+    void handleSensorStatusChanged();
+    void captureSensorData();
+    void handleSensorErrorOccurred( const QString &errorMessage );
+
+  private:
+
+    QList<QgsAbstractSensor *> mSensors;
+    QMap<QString, QgsAbstractSensor::SensorData> mSensorsData;
+
+};
+
+#endif // QGSSENSORMANAGER_H
diff --git a/src/core/sensor/qgssensormodel.cpp b/src/core/sensor/qgssensormodel.cpp
new file mode 100644
index 0000000000..dae8f27eb3
--- /dev/null
+++ b/src/core/sensor/qgssensormodel.cpp
@@ -0,0 +1,273 @@
+/***************************************************************************
+    qgssensormodel.cpp
+    ---------------
+    begin                : March 2023
+    copyright            : (C) 2023 by Mathieu pellerin
+    email                : mathieu at opengis dot ch
+ ***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "qgssensormodel.h"
+
+#include "qgis.h"
+#include "qgssensormanager.h"
+#include "qgsabstractsensor.h"
+
+
+QgsSensorModel::QgsSensorModel( QgsSensorManager *manager, QObject *parent )
+  : QAbstractItemModel( parent )
+  , mSensorManager( manager )
+{
+  connect( mSensorManager, &QgsSensorManager::sensorAdded, this, &QgsSensorModel::sensorAdded );
+  connect( mSensorManager, &QgsSensorManager::sensorAboutToBeRemoved, this, &QgsSensorModel::sensorRemoved );
+
+  connect( mSensorManager, &QgsSensorManager::sensorNameChanged, this, &QgsSensorModel::sensorNameChanged );
+  connect( mSensorManager, &QgsSensorManager::sensorStatusChanged, this, &QgsSensorModel::sensorStatusChanged );
+  connect( mSensorManager, &QgsSensorManager::sensorDataCaptured, this, &QgsSensorModel::sensorDataCaptured );
+
+  beginResetModel();
+  const QList<QgsAbstractSensor *> sensors = manager->sensors();
+  for ( const QgsAbstractSensor *sensor : sensors )
+  {
+    if ( !mSensorIds.contains( sensor->id() ) )
+    {
+      mSensorIds << sensor->id();
+    }
+  }
+  endResetModel();
+}
+
+QVariant QgsSensorModel::data( const QModelIndex &index, int role ) const
+{
+  if ( index.row() < 0 || index.row() >= rowCount( QModelIndex() ) )
+    return QVariant();
+
+  QgsAbstractSensor *sensor = mSensorManager->sensor( mSensorIds[index.row()] );
+  if ( !sensor )
+    return QVariant();
+
+  switch ( role )
+  {
+    case Qt::DisplayRole:
+    case Qt::ToolTipRole:
+    case Qt::EditRole:
+    {
+      switch ( index.column() )
+      {
+        case static_cast<int>( Column::Name ):
+        {
+          return sensor->name();
+        }
+
+        case static_cast<int>( Column::LastValue ):
+        {
+          switch ( sensor->status() )
+          {
+            case Qgis::DeviceConnectionStatus::Disconnected:
+              return tr( "Disconnected" );
+
+            case Qgis::DeviceConnectionStatus::Connecting:
+              return tr( "Connecting" );
+
+            case Qgis::DeviceConnectionStatus::Connected:
+              return sensor->data().lastValue.toString();
+          }
+        }
+
+        default:
+          break;
+      }
+
+      return QVariant();
+    }
+
+    case SensorType:
+    {
+      return sensor->type();
+    }
+
+    case SensorId:
+    {
+      return sensor->id();
+    }
+
+    case SensorName:
+    {
+      return sensor->name();
+    }
+
+    case SensorStatus:
+    {
+      return QVariant::fromValue<Qgis::DeviceConnectionStatus>( sensor->status() );
+    }
+
+    case SensorLastValue:
+    {
+      return sensor->data().lastValue;
+    }
+
+    case SensorLastTimestamp:
+    {
+      return sensor->data().lastTimestamp;
+    }
+
+    case Sensor:
+    {
+      return QVariant::fromValue<QgsAbstractSensor *>( sensor );
+    }
+
+    default:
+      return QVariant();
+  }
+  BUILTIN_UNREACHABLE
+}
+
+bool QgsSensorModel::setData( const QModelIndex &index, const QVariant &value, int role )
+{
+  if ( index.row() < 0 || index.row() >= rowCount( QModelIndex() ) || role != Qt::EditRole )
+    return false;
+
+  QgsAbstractSensor *sensor = mSensorManager->sensor( mSensorIds[index.row()] );
+  if ( !sensor )
+    return false;
+
+  switch ( index.column() )
+  {
+    case static_cast<int>( Column::Name ):
+    {
+      sensor->setName( value.toString() );
+      return true;
+    }
+
+    default:
+      break;
+  }
+
+  return false;
+}
+
+Qt::ItemFlags QgsSensorModel::flags( const QModelIndex &index ) const
+{
+  Qt::ItemFlags flags = QAbstractItemModel::flags( index );
+  if ( index.isValid() && index.column() == static_cast<int>( Column::Name ) )
+  {
+    QgsAbstractSensor *sensor = mSensorManager->sensor( mSensorIds[index.row()] );
+    if ( sensor )
+    {
+      return flags | Qt::ItemIsEditable;
+    }
+  }
+  return flags;
+}
+
+QVariant QgsSensorModel::headerData( int section, Qt::Orientation orientation, int role ) const
+{
+  if ( role == Qt::DisplayRole )
+  {
+    if ( orientation == Qt::Vertical ) //row
+    {
+      return QVariant( section + 1 );
+    }
+    else
+    {
+      switch ( section )
+      {
+        case static_cast<int>( Column::Name ):
+          return QVariant( tr( "Name" ) );
+
+        case static_cast<int>( Column::LastValue ):
+          return QVariant( tr( "Last Value" ) );
+
+        default:
+          return QVariant();
+      }
+    }
+  }
+  else
+  {
+    return QVariant();
+  }
+}
+
+QModelIndex QgsSensorModel::index( int row, int column, const QModelIndex &parent ) const
+{
+  if ( !hasIndex( row, column, parent ) )
+    return QModelIndex();
+
+  if ( !parent.isValid() )
+  {
+    return createIndex( row, column );
+  }
+
+  return QModelIndex();
+}
+
+QModelIndex QgsSensorModel::parent( const QModelIndex & ) const
+{
+  return QModelIndex();
+}
+
+int QgsSensorModel::rowCount( const QModelIndex &parent ) const
+{
+  if ( !parent.isValid() )
+  {
+    return mSensorIds.size();
+  }
+  return 0;
+}
+
+int QgsSensorModel::columnCount( const QModelIndex & ) const
+{
+  return 2;
+}
+
+void QgsSensorModel::sensorAdded( const QString &id )
+{
+  beginInsertRows( QModelIndex(), mSensorIds.size(), mSensorIds.size() );
+  mSensorIds << id;
+  endInsertRows();
+}
+
+void QgsSensorModel::sensorRemoved( const QString &id )
+{
+  const int sensorIndex = mSensorIds.indexOf( id );
+  if ( sensorIndex < 0 )
+    return;
+
+  beginRemoveRows( QModelIndex(), sensorIndex, sensorIndex );
+  mSensorIds.removeAt( sensorIndex );
+  endRemoveRows();
+}
+
+void QgsSensorModel::sensorNameChanged( const QString &id )
+{
+  const int sensorIndex = mSensorIds.indexOf( id );
+  if ( sensorIndex < 0 )
+    return;
+
+  emit dataChanged( index( sensorIndex, static_cast<int>( Column::Name ) ), index( sensorIndex, static_cast<int>( Column::Name ) ), QVector< int >() << Qt::DisplayRole << QgsSensorModel::SensorName );
+}
+
+void QgsSensorModel::sensorStatusChanged( const QString &id )
+{
+  const int sensorIndex = mSensorIds.indexOf( id );
+  if ( sensorIndex < 0 )
+    return;
+
+  emit dataChanged( index( sensorIndex, static_cast<int>( Column::LastValue ) ), index( sensorIndex, static_cast<int>( Column::LastValue ) ), QVector< int >() << QgsSensorModel::SensorStatus );
+}
+
+void QgsSensorModel::sensorDataCaptured( const QString &id )
+{
+  const int sensorIndex = mSensorIds.indexOf( id );
+  if ( sensorIndex < 0 )
+    return;
+
+  emit dataChanged( index( sensorIndex, static_cast<int>( Column::LastValue ) ), index( sensorIndex, static_cast<int>( Column::LastValue ) ), QVector< int >() << QgsSensorModel::SensorLastValue << QgsSensorModel::SensorLastTimestamp );
+}
diff --git a/src/core/sensor/qgssensormodel.h b/src/core/sensor/qgssensormodel.h
new file mode 100644
index 0000000000..412db53ea0
--- /dev/null
+++ b/src/core/sensor/qgssensormodel.h
@@ -0,0 +1,87 @@
+/***************************************************************************
+    qgssensormodel.h
+    ---------------
+    begin                : March 2023
+    copyright            : (C) 2023 by Mathieu pellerin
+    email                : mathieu at opengis dot ch
+ ***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef QGSSENSORMODEL_H
+#define QGSSENSORMODEL_H
+
+#include "qgis_core.h"
+#include "qgis_sip.h"
+
+#include <QAbstractItemModel>
+
+class QgsSensorManager;
+
+/**
+ * \ingroup core
+ * \class QgsSensorModel
+ * \brief A QAbstractItemModel subclass for showing sensors within a QgsSensorManager.
+ * \since QGIS 3.32
+ */
+class CORE_EXPORT QgsSensorModel: public QAbstractItemModel
+{
+    Q_OBJECT
+
+  public:
+
+    //! Model columns
+    enum class Column : int
+    {
+      Name = 0, //!< Name
+      LastValue = 1, //!< Last value
+    };
+
+    //! Custom model roles
+    enum Role
+    {
+      SensorType = Qt::UserRole + 1, //!< Sensor type
+      SensorId, //!< Sensor id
+      SensorName, //!< Sensor name
+      SensorStatus, //!< Sensor status (disconnected, connected, etc.)
+      SensorLastValue, //!< Sensor last captured value
+      SensorLastTimestamp, //!< Sensor timestamp of last captured value
+      Sensor, //!< Sensor object pointer
+    };
+
+    /**
+     * Constructor for QgsSensorModel, for the specified \a manager and \a parent object.
+     */
+    explicit QgsSensorModel( QgsSensorManager *manager, QObject *parent SIP_TRANSFERTHIS = nullptr );
+
+    QVariant data( const QModelIndex &index, int role ) const override;
+    bool setData( const QModelIndex &index, const QVariant &value, int role = Qt::EditRole ) override;
+    Qt::ItemFlags flags( const QModelIndex &index ) const override;
+    QVariant headerData( int section, Qt::Orientation orientation,
+                         int role = Qt::DisplayRole ) const override;
+    QModelIndex index( int row, int column,
+                       const QModelIndex &parent = QModelIndex() ) const override;
+    QModelIndex parent( const QModelIndex &index ) const override;
+    int rowCount( const QModelIndex &parent = QModelIndex() ) const override;
+    int columnCount( const QModelIndex &parent = QModelIndex() ) const override;
+
+  private slots:
+
+    void sensorAdded( const QString &id );
+    void sensorRemoved( const QString &id );
+    void sensorNameChanged( const QString &id );
+    void sensorStatusChanged( const QString &id );
+    void sensorDataCaptured( const QString &id );
+
+  private:
+
+    QgsSensorManager *mSensorManager = nullptr;
+    QStringList mSensorIds;
+};
+
+#endif //QGSSENSORMODEL_H
diff --git a/src/core/sensor/qgssensorregistry.cpp b/src/core/sensor/qgssensorregistry.cpp
new file mode 100644
index 0000000000..b9196be833
--- /dev/null
+++ b/src/core/sensor/qgssensorregistry.cpp
@@ -0,0 +1,99 @@
+/***************************************************************************
+                            qgssensorregistry.cpp
+                            ------------------------
+    begin                : March 2023
+    copyright            : (C) 2023 by Mathieu Pellerin
+    email                : mathieu at opengis dot ch
+ ***************************************************************************/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "qgsconfig.h"
+
+#include "qgssensorregistry.h"
+#include "qgsiodevicesensor.h"
+#include "qgsproject.h"
+#include "qgssensormanager.h"
+
+QgsSensorRegistry::QgsSensorRegistry( QObject *parent )
+  : QObject( parent )
+{
+}
+
+QgsSensorRegistry::~QgsSensorRegistry()
+{
+  qDeleteAll( mMetadata );
+}
+
+bool QgsSensorRegistry::populate()
+{
+  if ( !mMetadata.isEmpty() )
+    return false;
+
+  addSensorType( new QgsSensorMetadata( QLatin1String( "tcp_socket" ), QObject::tr( "TCP socket sensor" ), QgsTcpSocketSensor::create ) );
+  addSensorType( new QgsSensorMetadata( QLatin1String( "udp_socket" ), QObject::tr( "UDP socket sensor" ), QgsUdpSocketSensor::create ) );
+#if defined( HAVE_QTSERIALPORT )
+  addSensorType( new QgsSensorMetadata( QLatin1String( "serial_port" ), QObject::tr( "Serial port sensor" ), QgsSerialPortSensor::create ) );
+#endif
+
+  return true;
+}
+
+QgsSensorAbstractMetadata *QgsSensorRegistry::sensorMetadata( const QString &type ) const
+{
+  return mMetadata.value( type );
+}
+
+bool QgsSensorRegistry::addSensorType( QgsSensorAbstractMetadata *metadata )
+{
+  if ( !metadata || mMetadata.contains( metadata->type() ) )
+    return false;
+
+  mMetadata[metadata->type()] = metadata;
+  emit sensorAdded( metadata->type(), metadata->visibleName() );
+  return true;
+}
+
+bool QgsSensorRegistry::removeSensorType( const QString &type )
+{
+  if ( !mMetadata.contains( type ) )
+    return false;
+
+  // remove any sensor of this type in the project sensor manager
+  const QList<QgsAbstractSensor *> sensors = QgsProject::instance()->sensorManager()->sensors();
+  for ( QgsAbstractSensor *sensor : sensors )
+  {
+    if ( sensor->type() == type )
+    {
+      QgsProject::instance()->sensorManager()->removeSensor( sensor->id() );
+    }
+  }
+
+  delete mMetadata.take( type );
+  return true;
+}
+
+QgsAbstractSensor *QgsSensorRegistry::createSensor( const QString &type, QObject *parent ) const
+{
+  if ( !mMetadata.contains( type ) )
+    return nullptr;
+
+  return mMetadata[type]->createSensor( parent );
+}
+
+QMap<QString, QString> QgsSensorRegistry::sensorTypes() const
+{
+  QMap<QString, QString> types;
+  for ( auto it = mMetadata.constBegin(); it != mMetadata.constEnd(); ++it )
+  {
+    types.insert( it.key(), it.value()->visibleName() );
+  }
+
+  return types;
+}
diff --git a/src/core/sensor/qgssensorregistry.h b/src/core/sensor/qgssensorregistry.h
new file mode 100644
index 0000000000..767ecc0069
--- /dev/null
+++ b/src/core/sensor/qgssensorregistry.h
@@ -0,0 +1,223 @@
+/***************************************************************************
+                            qgssensorregistry.h
+                            ------------------------
+    begin                : March 2023
+    copyright            : (C) 2023 by Mathieu Pellerin
+    email                : mathieu at opengis dot ch
+ ***************************************************************************/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef QGSSENSORREGISTRY_H
+#define QGSSENSORREGISTRY_H
+
+#include "qgis_core.h"
+#include "qgis_sip.h"
+#include "qgsapplication.h"
+#include "qgsabstractsensor.h"
+
+/**
+ * \ingroup core
+ * \brief Stores metadata about a sensor class.
+ *
+ * \note In C++ you can use QgsSensorAbstractMetadata convenience class.
+ * \since QGIS 3.32
+ */
+class CORE_EXPORT QgsSensorAbstractMetadata
+{
+  public:
+
+    /**
+     * Constructor for QgsSensorAbstractMetadata with the specified class \a type.
+     */
+    QgsSensorAbstractMetadata( const QString &type, const QString &visibleName )
+      : mType( type )
+      , mVisibleName( visibleName )
+    {}
+
+    virtual ~QgsSensorAbstractMetadata() = default;
+
+    /**
+     * Returns the unique type code for the sensor class.
+     */
+    QString type() const { return mType; }
+
+    /**
+     * Returns a translated, user visible name for the sensor class.
+     */
+    QString visibleName() const { return mVisibleName; }
+
+    /*
+     * IMPORTANT: While it seems like /Factory/ would be the correct annotations here, that's not
+     * the case.
+     * As per Phil Thomson's advice on https://www.riverbankcomputing.com/pipermail/pyqt/2017-July/039450.html:
+     *
+     * "
+     * /Factory/ is used when the instance returned is guaranteed to be new to Python.
+     * In this case it isn't because it has already been seen when being returned by QgsProcessingAlgorithm::createInstance()
+     * (However for a different sub-class implemented in C++ then it would be the first time it was seen
+     * by Python so the /Factory/ on create() would be correct.)
+     *
+     * You might try using /TransferBack/ on create() instead - that might be the best compromise.
+     * "
+     */
+
+    /**
+     * Creates a sensor of this class.
+     */
+    virtual QgsAbstractSensor *createSensor( QObject *parent ) = 0 SIP_TRANSFERBACK;
+
+  private:
+
+    QString mType;
+    QString mVisibleName;
+};
+
+//! Sensor creation function
+typedef std::function<QgsAbstractSensor *( QObject *parent )> QgsSensorCreateFunc SIP_SKIP;
+
+#ifndef SIP_RUN
+
+/**
+ * \ingroup core
+ * \brief Convenience metadata class that uses static functions to create sensors and their configuration widgets.
+ * \note not available in Python bindings
+ * \since QGIS 3.0
+ */
+class CORE_EXPORT QgsSensorMetadata : public QgsSensorAbstractMetadata
+{
+  public:
+
+    /**
+     * Constructor for QgsSensorMetadata with the specified class \a type.
+     */
+    QgsSensorMetadata( const QString &type, const QString &visibleName,
+                       const QgsSensorCreateFunc &pfCreate )
+      : QgsSensorAbstractMetadata( type, visibleName )
+      , mCreateFunc( pfCreate )
+    {}
+
+    /**
+     * Returns the classes' sensor creation function.
+     */
+    QgsSensorCreateFunc createFunction() const { return mCreateFunc; }
+
+    QgsAbstractSensor *createSensor( QObject *parent ) override { return mCreateFunc ? mCreateFunc( parent ) : nullptr; }
+
+  protected:
+    QgsSensorCreateFunc mCreateFunc = nullptr;
+
+};
+
+#endif
+
+/**
+ * \ingroup core
+ * \class QgsSensorRegistry
+ * \brief Registry of available sensor types.
+ *
+ * QgsSensorRegistry is not usually directly created, but rather accessed through
+ * QgsApplication::sensorRegistry().
+ *
+ * A companion class, QgsSensorGuiRegistry, handles the GUI behavior
+ * of sensors.
+ *
+ * \since QGIS 3.32
+ */
+class CORE_EXPORT QgsSensorRegistry : public QObject
+{
+    Q_OBJECT
+
+  public:
+
+    /**
+     * Creates a new empty item registry.
+     *
+     * QgsSensorRegistry is not usually directly created, but rather accessed through
+     * QgsApplication::sensorRegistry().
+     *
+     * \see populate()
+    */
+    QgsSensorRegistry( QObject *parent = nullptr );
+    ~QgsSensorRegistry() override;
+
+    /**
+     * Populates the registry with standard sensor types. If called on a non-empty registry
+     * then this will have no effect and will return FALSE.
+     */
+    bool populate();
+
+    //! QgsSensorRegistry cannot be copied.
+    QgsSensorRegistry( const QgsSensorRegistry &rh ) = delete;
+    //! QgsSensorRegistry cannot be copied.
+    QgsSensorRegistry &operator=( const QgsSensorRegistry &rh ) = delete;
+
+    /**
+     * Returns the metadata for the specified sensor \a type. Returns NULLPTR if
+     * a corresponding type was not found in the registry.
+     */
+    QgsSensorAbstractMetadata *sensorMetadata( const QString &type ) const;
+
+    /*
+     * IMPORTANT: While it seems like /Factory/ would be the correct annotations here, that's not
+     * the case.
+     * As per Phil Thomson's advice on https://www.riverbankcomputing.com/pipermail/pyqt/2017-July/039450.html:
+     *
+     * "
+     * /Factory/ is used when the instance returned is guaranteed to be new to Python.
+     * In this case it isn't because it has already been seen when being returned by QgsProcessingAlgorithm::createInstance()
+     * (However for a different sub-class implemented in C++ then it would be the first time it was seen
+     * by Python so the /Factory/ on create() would be correct.)
+     *
+     * You might try using /TransferBack/ on create() instead - that might be the best compromise.
+     * "
+     */
+
+    /**
+     * Registers a new sensor type.
+     * \note Takes ownership of the metadata instance.
+     */
+    bool addSensorType( QgsSensorAbstractMetadata *metadata SIP_TRANSFER );
+
+    /**
+     * Removes a new a sensor type from the registry.
+     */
+    bool removeSensorType( const QString &type );
+
+    /**
+     * Creates a new instance of a sensor given the \a type.
+     */
+    QgsAbstractSensor *createSensor( const QString &type, QObject *parent = nullptr ) const SIP_TRANSFERBACK;
+
+    /**
+     * Returns a map of available sensor types to translated name.
+     */
+    QMap<QString, QString> sensorTypes() const;
+
+  signals:
+
+    /**
+     * Emitted whenever a new sensor type is added to the registry, with the specified
+     * \a type and visible \a name.
+     */
+    void sensorAdded( const QString &type, const QString &name );
+
+  private:
+
+#ifdef SIP_RUN
+    QgsSensorRegistry( const QgsSensorRegistry &rh );
+#endif
+
+    QMap<QString, QgsSensorAbstractMetadata *> mMetadata;
+
+};
+
+#endif //QGSSENSORREGISTRY_H
+
+
+
diff --git a/tests/src/python/CMakeLists.txt b/tests/src/python/CMakeLists.txt
index cd38c254f2..8b807aaf7a 100644
--- a/tests/src/python/CMakeLists.txt
+++ b/tests/src/python/CMakeLists.txt
@@ -289,6 +289,9 @@ ADD_PYTHON_TEST(PyQgsProviderConnectionComboBox test_qgsproviderconnectioncombob
 ADD_PYTHON_TEST(PyQgsProviderConnectionModel test_qgsproviderconnectionmodel.py)
 ADD_PYTHON_TEST(PyQgsProviderConnectionGpkg test_qgsproviderconnection_ogr_gpkg.py)
 ADD_PYTHON_TEST(PyQgsProviderConnectionSpatialite test_qgsproviderconnection_spatialite.py)
+ADD_PYTHON_TEST(PyQgsSensorManager test_qgssensormanager.py)
+ADD_PYTHON_TEST(PyQgsSensorRegistry test_qgssensorregistry.py)
+ADD_PYTHON_TEST(PyQgsSensorModel test_qgssensormodel.py)
 ADD_PYTHON_TEST(PyQgsStyleStorageSpatialite test_stylestorage_spatialite.py)
 ADD_PYTHON_TEST(PyQgsStyleStorageGpkg test_stylestorage_gpkg.py)
 ADD_PYTHON_TEST(PyQgsProviderRegistry test_qgsproviderregistry.py)
diff --git a/tests/src/python/test_qgssensormanager.py b/tests/src/python/test_qgssensormanager.py
new file mode 100644
index 0000000000..2c4d300e97
--- /dev/null
+++ b/tests/src/python/test_qgssensormanager.py
@@ -0,0 +1,151 @@
+"""QGIS Unit tests for QgsSensorManager and its related classes.
+
+.. note:: This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+"""
+__author__ = '(C) 2023 by Mathieu Pellerin'
+__date__ = '19/03/2023'
+__copyright__ = 'Copyright 2023, The QGIS Project'
+
+import os
+
+import qgis  # NOQA
+from qgis.PyQt.QtCore import QCoreApplication, QEvent, QLocale, QTemporaryDir, QIODevice, QBuffer
+from qgis.PyQt.QtTest import QSignalSpy
+from qgis.PyQt.QtXml import QDomDocument
+from qgis.core import (
+    Qgis,
+    QgsApplication,
+    QgsAbstractSensor,
+    QgsExpression,
+    QgsExpressionContext,
+    QgsExpressionContextUtils,
+    QgsIODeviceSensor,
+    QgsProject,
+    QgsSensorManager
+)
+from qgis.testing import start_app, unittest
+
+from utilities import unitTestDataPath
+
+start_app()
+TEST_DATA_DIR = unitTestDataPath()
+
+
+class TestSensor(QgsIODeviceSensor):
+
+    buffer = None
+
+    def __init__(self):
+        super().__init__()
+        self.buffer = QBuffer()
+        self.initIODevice(self.buffer)
+
+    def handleConnect(self):
+        self.buffer.open(QIODevice.ReadWrite)
+        self.setStatus(Qgis.DeviceConnectionStatus.Connected)
+
+    def handleDisconnect(self):
+        self.buffer.close()
+
+    def pushData(self, data):
+        self.buffer.buffer().clear()
+        self.buffer.seek(0)
+        self.buffer.write(data.encode('ascii'))
+        self.buffer.seek(0)
+
+
+class TestQgsSensorManager(unittest.TestCase):
+
+    manager = None
+    sensor = None
+
+    @classmethod
+    def setUpClass(cls):
+        """Run before all tests"""
+        QCoreApplication.setOrganizationName("QGIS_Test")
+        QCoreApplication.setOrganizationDomain("QGIS_TestQgsSensorManager.com")
+        QCoreApplication.setApplicationName("QGIS_TestQgsSensorManager")
+        QLocale.setDefault(QLocale(QLocale.English))
+        start_app()
+
+        cls.manager = QgsProject.instance().sensorManager()
+        cls.sensor = TestSensor()
+        cls.manager.addSensor(cls.sensor)
+
+    def setUp(self):
+        """Run before each test."""
+        pass
+
+    def tearDown(self):
+        """Run after each test."""
+        self.sensor.disconnectSensor()
+        self.sensor.setName('')
+        pass
+
+    def testManagerAddRemove(self):
+        sensor1 = TestSensor()
+        sensor1_id = sensor1.id()
+
+        manager_added_spy = QSignalSpy(self.manager.sensorAdded)
+
+        self.manager.addSensor(sensor1)
+        self.assertEqual(len(manager_added_spy), 1)
+        self.assertTrue(self.manager.sensor(sensor1_id))
+
+        manager_abouttoberemoved_spy = QSignalSpy(self.manager.sensorAboutToBeRemoved)
+        manager_removed_spy = QSignalSpy(self.manager.sensorRemoved)
+
+        self.assertTrue(self.manager.removeSensor(sensor1_id))
+        self.assertEqual(len(manager_abouttoberemoved_spy), 1)
+        self.assertEqual(len(manager_removed_spy), 1)
+
+    def testNameAndStatus(self):
+        self.assertEqual(self.sensor.name(), '')
+        self.sensor.setName('test sensor')
+        self.assertEqual(self.sensor.name(), 'test sensor')
+
+        self.assertEqual(self.sensor.status(), Qgis.DeviceConnectionStatus.Disconnected)
+        self.sensor.connectSensor()
+        self.assertEqual(self.sensor.status(), Qgis.DeviceConnectionStatus.Connected)
+
+    def testProcessData(self):
+        self.sensor.setName('test sensor')
+        self.sensor.connectSensor()
+        self.assertEqual(self.sensor.status(), Qgis.DeviceConnectionStatus.Connected)
+
+        sensor_spy = QSignalSpy(self.sensor.dataChanged)
+        manager_spy = QSignalSpy(self.manager.sensorDataCaptured)
+
+        self.sensor.pushData('test string')
+        manager_spy.wait()
+        self.assertEqual(len(sensor_spy), 1)
+        self.assertEqual(len(manager_spy), 1)
+        self.assertEqual(self.sensor.data().lastValue, 'test string')
+        self.assertEqual(self.manager.sensorData('test sensor').lastValue, 'test string')
+
+    def testSensorDataExpression(self):
+        self.sensor.setName('test sensor')
+        self.sensor.connectSensor()
+        self.assertEqual(self.sensor.status(), Qgis.DeviceConnectionStatus.Connected)
+
+        data_spy = QSignalSpy(self.sensor.dataChanged)
+
+        self.sensor.pushData('test string 2')
+        data_spy.wait()
+        self.assertEqual(len(data_spy), 1)
+        self.assertEqual(self.sensor.data().lastValue, 'test string 2')
+
+        expression = QgsExpression('sensor_data(\'test sensor\')')
+
+        context = QgsExpressionContext()
+        context.appendScope(QgsExpressionContextUtils.projectScope(QgsProject.instance()))
+
+        result = expression.evaluate(context)
+        self.assertEqual(result, 'test string 2')
+
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/tests/src/python/test_qgssensormodel.py b/tests/src/python/test_qgssensormodel.py
new file mode 100644
index 0000000000..e86a28b196
--- /dev/null
+++ b/tests/src/python/test_qgssensormodel.py
@@ -0,0 +1,129 @@
+"""QGIS Unit tests for QgsSensorModel and its related classes.
+
+.. note:: This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+"""
+__author__ = '(C) 2023 by Mathieu Pellerin'
+__date__ = '19/03/2023'
+__copyright__ = 'Copyright 2023, The QGIS Project'
+
+import os
+
+import qgis  # NOQA
+from qgis.PyQt.QtCore import QCoreApplication, QEvent, QLocale, QTemporaryDir, QIODevice, QBuffer, QDateTime
+from qgis.PyQt.QtTest import QSignalSpy
+from qgis.PyQt.QtXml import QDomDocument
+from qgis.core import (
+    Qgis,
+    QgsApplication,
+    QgsAbstractSensor,
+    QgsExpression,
+    QgsExpressionContext,
+    QgsExpressionContextUtils,
+    QgsIODeviceSensor,
+    QgsProject,
+    QgsSensorManager,
+    QgsSensorModel,
+    QgsTcpSocketSensor,
+)
+from qgis.testing import start_app, unittest
+
+from utilities import unitTestDataPath
+
+start_app()
+TEST_DATA_DIR = unitTestDataPath()
+
+
+class TestSensor(QgsIODeviceSensor):
+
+    buffer = None
+
+    def __init__(self):
+        super().__init__()
+        self.buffer = QBuffer()
+        self.initIODevice(self.buffer)
+
+    def type(self):
+        return "test_sensor"
+
+    def handleConnect(self):
+        self.buffer.open(QIODevice.ReadWrite)
+        self.setStatus(Qgis.DeviceConnectionStatus.Connected)
+
+    def handleDisconnect(self):
+        self.buffer.close()
+
+    def pushData(self, data):
+        self.buffer.buffer().clear()
+        self.buffer.seek(0)
+        self.buffer.write(data.encode('ascii'))
+        self.buffer.seek(0)
+
+
+class TestQgsSensorModel(unittest.TestCase):
+
+    manager = None
+    model = None
+
+    @classmethod
+    def setUpClass(cls):
+        """Run before all tests"""
+        QCoreApplication.setOrganizationName("QGIS_Test")
+        QCoreApplication.setOrganizationDomain("QGIS_TestQgsSensorManager.com")
+        QCoreApplication.setApplicationName("QGIS_TestQgsSensorManager")
+        QLocale.setDefault(QLocale(QLocale.English))
+        start_app()
+
+        cls.manager = QgsProject.instance().sensorManager()
+        cls.model = QgsSensorModel(cls.manager)
+
+    def setUp(self):
+        """Run before each test."""
+        pass
+
+    def tearDown(self):
+        """Run after each test."""
+        pass
+
+    def testModel(self):
+        sensor1 = QgsTcpSocketSensor()
+        sensor1.setName('name1')
+        sensor2 = TestSensor()
+        sensor2.setName('name2')
+
+        model_row_inserted_spy = QSignalSpy(self.model.rowsInserted)
+
+        self.manager.addSensor(sensor1)
+        self.assertEqual(len(model_row_inserted_spy), 1)
+        self.manager.addSensor(sensor2)
+        self.assertEqual(len(model_row_inserted_spy), 2)
+        self.assertEqual(self.model.rowCount(), 2)
+
+        model_row_removed_spy = QSignalSpy(self.model.rowsRemoved)
+
+        self.manager.removeSensor(sensor1.id())
+        self.assertEqual(len(model_row_removed_spy), 1)
+        self.assertEqual(self.model.rowCount(), 1)
+
+        self.assertEqual(self.model.data(self.model.index(0, 0), QgsSensorModel.SensorId), sensor2.id())
+        self.assertEqual(self.model.data(self.model.index(0, 0), QgsSensorModel.SensorName), sensor2.name())
+        self.assertEqual(self.model.data(self.model.index(0, 0), QgsSensorModel.SensorLastValue), None)
+        self.assertEqual(self.model.data(self.model.index(0, 0), QgsSensorModel.SensorLastTimestamp), None)
+        self.assertEqual(self.model.data(self.model.index(0, 0), QgsSensorModel.Sensor), sensor2)
+
+        model_data_changed_spy = QSignalSpy(self.model.dataChanged)
+
+        sensor2.setName('new name2')
+        sensor2.connectSensor()
+        sensor2.pushData('test string')
+        model_data_changed_spy.wait()
+        self.assertEqual(len(model_data_changed_spy), 4)  # new name, connecting + connected state, and data change signals
+        self.assertEqual(self.model.data(self.model.index(0, 0), QgsSensorModel.SensorName), sensor2.name())
+        self.assertEqual(self.model.data(self.model.index(0, 0), QgsSensorModel.SensorLastValue), sensor2.data().lastValue)
+        self.assertEqual(self.model.data(self.model.index(0, 0), QgsSensorModel.SensorLastTimestamp), sensor2.data().lastTimestamp)
+
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/tests/src/python/test_qgssensorregistry.py b/tests/src/python/test_qgssensorregistry.py
new file mode 100644
index 0000000000..5ab0331972
--- /dev/null
+++ b/tests/src/python/test_qgssensorregistry.py
@@ -0,0 +1,63 @@
+"""QGIS Unit tests for QgsSensorRegistry
+
+.. note:: This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+"""
+__author__ = 'Mathieu Pellerin'
+__date__ = '19/03/2023'
+__copyright__ = 'Copyright 2023, The QGIS Project'
+
+import qgis  # NOQA
+
+from qgis.core import QgsSensorRegistry, QgsSensorAbstractMetadata, QgsTcpSocketSensor, QgsUdpSocketSensor
+from qgis.testing import start_app, unittest
+
+start_app()
+
+
+class TestTcpSensorMetadata(QgsSensorAbstractMetadata):
+
+    def __init__(self):
+        super().__init__("test_tcp_sensor", "test tcp sensor")
+
+    def createSensor(self, parent):
+        return QgsTcpSocketSensor(parent)
+
+
+class TestUdpSensorMetadata(QgsSensorAbstractMetadata):
+
+    def __init__(self):
+        super().__init__("test_udp_sensor", "test udp sensor")
+
+    def createSensor(self, parent):
+        return QgsUdpSocketSensor(parent)
+
+
+class TestQgsSensorRegistry(unittest.TestCase):
+
+    def testRegistry(self):
+        registry = QgsSensorRegistry()
+
+        registry.addSensorType(TestTcpSensorMetadata())
+        registry.addSensorType(TestUdpSensorMetadata())
+        self.assertEqual(registry.sensorTypes(), {'test_tcp_sensor': 'test tcp sensor', 'test_udp_sensor': 'test udp sensor'})
+
+        sensor = registry.createSensor('test_tcp_sensor')
+        self.assertTrue(sensor)
+        self.assertEqual(sensor.type(), 'tcp_socket')
+
+        sensor = registry.createSensor('test_udp_sensor')
+        self.assertTrue(sensor)
+        self.assertEqual(sensor.type(), 'udp_socket')
+
+        sensor = registry.createSensor('invalid_sensor_type')
+        self.assertFalse(sensor)
+
+        registry.removeSensorType('test_tcp_sensor')
+        self.assertEqual(registry.sensorTypes(), {'test_udp_sensor': 'test udp sensor'})
+
+
+if __name__ == '__main__':
+    unittest.main()
